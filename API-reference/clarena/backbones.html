<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="pdoc 15.0.1"/>
    <title>clarena.backbones API documentation</title>

    <style>/*! * Bootstrap Reboot v5.0.0 (https://getbootstrap.com/) * Copyright 2011-2021 The Bootstrap Authors * Copyright 2011-2021 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md) */*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","Liberation Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-size:1rem;font-weight:400;line-height:1.5;color:#212529;background-color:#fff;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}hr{margin:1rem 0;color:inherit;background-color:currentColor;border:0;opacity:.25}hr:not([size]){height:1px}h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:.5rem;font-weight:500;line-height:1.2}h1{font-size:calc(1.375rem + 1.5vw)}@media (min-width:1200px){h1{font-size:2.5rem}}h2{font-size:calc(1.325rem + .9vw)}@media (min-width:1200px){h2{font-size:2rem}}h3{font-size:calc(1.3rem + .6vw)}@media (min-width:1200px){h3{font-size:1.75rem}}h4{font-size:calc(1.275rem + .3vw)}@media (min-width:1200px){h4{font-size:1.5rem}}h5{font-size:1.25rem}h6{font-size:1rem}p{margin-top:0;margin-bottom:1rem}abbr[data-bs-original-title],abbr[title]{-webkit-text-decoration:underline dotted;text-decoration:underline dotted;cursor:help;-webkit-text-decoration-skip-ink:none;text-decoration-skip-ink:none}address{margin-bottom:1rem;font-style:normal;line-height:inherit}ol,ul{padding-left:2rem}dl,ol,ul{margin-top:0;margin-bottom:1rem}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}dt{font-weight:700}dd{margin-bottom:.5rem;margin-left:0}blockquote{margin:0 0 1rem}b,strong{font-weight:bolder}small{font-size:.875em}mark{padding:.2em;background-color:#fcf8e3}sub,sup{position:relative;font-size:.75em;line-height:0;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}a{color:#0d6efd;text-decoration:underline}a:hover{color:#0a58ca}a:not([href]):not([class]),a:not([href]):not([class]):hover{color:inherit;text-decoration:none}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:1em;direction:ltr;unicode-bidi:bidi-override}pre{display:block;margin-top:0;margin-bottom:1rem;overflow:auto;font-size:.875em}pre code{font-size:inherit;color:inherit;word-break:normal}code{font-size:.875em;color:#d63384;word-wrap:break-word}a>code{color:inherit}kbd{padding:.2rem .4rem;font-size:.875em;color:#fff;background-color:#212529;border-radius:.2rem}kbd kbd{padding:0;font-size:1em;font-weight:700}figure{margin:0 0 1rem}img,svg{vertical-align:middle}table{caption-side:bottom;border-collapse:collapse}caption{padding-top:.5rem;padding-bottom:.5rem;color:#6c757d;text-align:left}th{text-align:inherit;text-align:-webkit-match-parent}tbody,td,tfoot,th,thead,tr{border-color:inherit;border-style:solid;border-width:0}label{display:inline-block}button{border-radius:0}button:focus:not(:focus-visible){outline:0}button,input,optgroup,select,textarea{margin:0;font-family:inherit;font-size:inherit;line-height:inherit}button,select{text-transform:none}[role=button]{cursor:pointer}select{word-wrap:normal}select:disabled{opacity:1}[list]::-webkit-calendar-picker-indicator{display:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]:not(:disabled),[type=reset]:not(:disabled),[type=submit]:not(:disabled),button:not(:disabled){cursor:pointer}::-moz-focus-inner{padding:0;border-style:none}textarea{resize:vertical}fieldset{min-width:0;padding:0;margin:0;border:0}legend{float:left;width:100%;padding:0;margin-bottom:.5rem;font-size:calc(1.275rem + .3vw);line-height:inherit}@media (min-width:1200px){legend{font-size:1.5rem}}legend+*{clear:left}::-webkit-datetime-edit-day-field,::-webkit-datetime-edit-fields-wrapper,::-webkit-datetime-edit-hour-field,::-webkit-datetime-edit-minute,::-webkit-datetime-edit-month-field,::-webkit-datetime-edit-text,::-webkit-datetime-edit-year-field{padding:0}::-webkit-inner-spin-button{height:auto}[type=search]{outline-offset:-2px;-webkit-appearance:textfield}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-color-swatch-wrapper{padding:0}::file-selector-button{font:inherit}::-webkit-file-upload-button{font:inherit;-webkit-appearance:button}output{display:inline-block}iframe{border:0}summary{display:list-item;cursor:pointer}progress{vertical-align:baseline}[hidden]{display:none!important}</style>
    <style>/*! syntax-highlighting.css */pre{line-height:125%;}span.linenos{color:inherit; background-color:transparent; padding-left:5px; padding-right:20px;}.pdoc-code .hll{background-color:#ffffcc}.pdoc-code{background:#f8f8f8;}.pdoc-code .c{color:#3D7B7B; font-style:italic}.pdoc-code .err{border:1px solid #FF0000}.pdoc-code .k{color:#008000; font-weight:bold}.pdoc-code .o{color:#666666}.pdoc-code .ch{color:#3D7B7B; font-style:italic}.pdoc-code .cm{color:#3D7B7B; font-style:italic}.pdoc-code .cp{color:#9C6500}.pdoc-code .cpf{color:#3D7B7B; font-style:italic}.pdoc-code .c1{color:#3D7B7B; font-style:italic}.pdoc-code .cs{color:#3D7B7B; font-style:italic}.pdoc-code .gd{color:#A00000}.pdoc-code .ge{font-style:italic}.pdoc-code .gr{color:#E40000}.pdoc-code .gh{color:#000080; font-weight:bold}.pdoc-code .gi{color:#008400}.pdoc-code .go{color:#717171}.pdoc-code .gp{color:#000080; font-weight:bold}.pdoc-code .gs{font-weight:bold}.pdoc-code .gu{color:#800080; font-weight:bold}.pdoc-code .gt{color:#0044DD}.pdoc-code .kc{color:#008000; font-weight:bold}.pdoc-code .kd{color:#008000; font-weight:bold}.pdoc-code .kn{color:#008000; font-weight:bold}.pdoc-code .kp{color:#008000}.pdoc-code .kr{color:#008000; font-weight:bold}.pdoc-code .kt{color:#B00040}.pdoc-code .m{color:#666666}.pdoc-code .s{color:#BA2121}.pdoc-code .na{color:#687822}.pdoc-code .nb{color:#008000}.pdoc-code .nc{color:#0000FF; font-weight:bold}.pdoc-code .no{color:#880000}.pdoc-code .nd{color:#AA22FF}.pdoc-code .ni{color:#717171; font-weight:bold}.pdoc-code .ne{color:#CB3F38; font-weight:bold}.pdoc-code .nf{color:#0000FF}.pdoc-code .nl{color:#767600}.pdoc-code .nn{color:#0000FF; font-weight:bold}.pdoc-code .nt{color:#008000; font-weight:bold}.pdoc-code .nv{color:#19177C}.pdoc-code .ow{color:#AA22FF; font-weight:bold}.pdoc-code .w{color:#bbbbbb}.pdoc-code .mb{color:#666666}.pdoc-code .mf{color:#666666}.pdoc-code .mh{color:#666666}.pdoc-code .mi{color:#666666}.pdoc-code .mo{color:#666666}.pdoc-code .sa{color:#BA2121}.pdoc-code .sb{color:#BA2121}.pdoc-code .sc{color:#BA2121}.pdoc-code .dl{color:#BA2121}.pdoc-code .sd{color:#BA2121; font-style:italic}.pdoc-code .s2{color:#BA2121}.pdoc-code .se{color:#AA5D1F; font-weight:bold}.pdoc-code .sh{color:#BA2121}.pdoc-code .si{color:#A45A77; font-weight:bold}.pdoc-code .sx{color:#008000}.pdoc-code .sr{color:#A45A77}.pdoc-code .s1{color:#BA2121}.pdoc-code .ss{color:#19177C}.pdoc-code .bp{color:#008000}.pdoc-code .fm{color:#0000FF}.pdoc-code .vc{color:#19177C}.pdoc-code .vg{color:#19177C}.pdoc-code .vi{color:#19177C}.pdoc-code .vm{color:#19177C}.pdoc-code .il{color:#666666}</style>
    <style>/*! theme.css */:root{--pdoc-background:#fff;}.pdoc{--text:#212529;--muted:#6c757d;--link:#3660a5;--link-hover:#1659c5;--code:#f8f8f8;--active:#fff598;--accent:#eee;--accent2:#c1c1c1;--nav-hover:rgba(255, 255, 255, 0.5);--name:#0066BB;--def:#008800;--annotation:#007020;}</style>
    <style>/*! layout.css */html, body{width:100%;height:100%;}html, main{scroll-behavior:smooth;}body{background-color:var(--pdoc-background);}@media (max-width:769px){#navtoggle{cursor:pointer;position:absolute;width:50px;height:40px;top:1rem;right:1rem;border-color:var(--text);color:var(--text);display:flex;opacity:0.8;z-index:999;}#navtoggle:hover{opacity:1;}#togglestate + div{display:none;}#togglestate:checked + div{display:inherit;}main, header{padding:2rem 3vw;}header + main{margin-top:-3rem;}.git-button{display:none !important;}nav input[type="search"]{max-width:77%;}nav input[type="search"]:first-child{margin-top:-6px;}nav input[type="search"]:valid ~ *{display:none !important;}}@media (min-width:770px){:root{--sidebar-width:clamp(12.5rem, 28vw, 22rem);}nav{position:fixed;overflow:auto;height:100vh;width:var(--sidebar-width);}main, header{padding:3rem 2rem 3rem calc(var(--sidebar-width) + 3rem);width:calc(54rem + var(--sidebar-width));max-width:100%;}header + main{margin-top:-4rem;}#navtoggle{display:none;}}#togglestate{position:absolute;height:0;opacity:0;}nav.pdoc{--pad:clamp(0.5rem, 2vw, 1.75rem);--indent:1.5rem;background-color:var(--accent);border-right:1px solid var(--accent2);box-shadow:0 0 20px rgba(50, 50, 50, .2) inset;padding:0 0 0 var(--pad);overflow-wrap:anywhere;scrollbar-width:thin; scrollbar-color:var(--accent2) transparent; z-index:1}nav.pdoc::-webkit-scrollbar{width:.4rem; }nav.pdoc::-webkit-scrollbar-thumb{background-color:var(--accent2); }nav.pdoc > div{padding:var(--pad) 0;}nav.pdoc .module-list-button{display:inline-flex;align-items:center;color:var(--text);border-color:var(--muted);margin-bottom:1rem;}nav.pdoc .module-list-button:hover{border-color:var(--text);}nav.pdoc input[type=search]{display:block;outline-offset:0;width:calc(100% - var(--pad));}nav.pdoc .logo{max-width:calc(100% - var(--pad));max-height:35vh;display:block;margin:0 auto 1rem;transform:translate(calc(-.5 * var(--pad)), 0);}nav.pdoc ul{list-style:none;padding-left:0;}nav.pdoc > div > ul{margin-left:calc(0px - var(--pad));}nav.pdoc li a{padding:.2rem 0 .2rem calc(var(--pad) + var(--indent));}nav.pdoc > div > ul > li > a{padding-left:var(--pad);}nav.pdoc li{transition:all 100ms;}nav.pdoc li:hover{background-color:var(--nav-hover);}nav.pdoc a, nav.pdoc a:hover{color:var(--text);}nav.pdoc a{display:block;}nav.pdoc > h2:first-of-type{margin-top:1.5rem;}nav.pdoc .class:before{content:"class ";color:var(--muted);}nav.pdoc .function:after{content:"()";color:var(--muted);}nav.pdoc footer:before{content:"";display:block;width:calc(100% - var(--pad));border-top:solid var(--accent2) 1px;margin-top:1.5rem;padding-top:.5rem;}nav.pdoc footer{font-size:small;}</style>
    <style>/*! content.css */.pdoc{color:var(--text);box-sizing:border-box;line-height:1.5;background:none;}.pdoc .pdoc-button{cursor:pointer;display:inline-block;border:solid black 1px;border-radius:2px;font-size:.75rem;padding:calc(0.5em - 1px) 1em;transition:100ms all;}.pdoc .alert{padding:1rem 1rem 1rem calc(1.5rem + 24px);border:1px solid transparent;border-radius:.25rem;background-repeat:no-repeat;background-position:.75rem center;margin-bottom:1rem;}.pdoc .alert > em{display:none;}.pdoc .alert > *:last-child{margin-bottom:0;}.pdoc .alert.note {color:#084298;background-color:#cfe2ff;border-color:#b6d4fe;background-image:url("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2224%22%20height%3D%2224%22%20fill%3D%22%23084298%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M8%2016A8%208%200%201%200%208%200a8%208%200%200%200%200%2016zm.93-9.412-1%204.705c-.07.34.029.533.304.533.194%200%20.487-.07.686-.246l-.088.416c-.287.346-.92.598-1.465.598-.703%200-1.002-.422-.808-1.319l.738-3.468c.064-.293.006-.399-.287-.47l-.451-.081.082-.381%202.29-.287zM8%205.5a1%201%200%201%201%200-2%201%201%200%200%201%200%202z%22/%3E%3C/svg%3E");}.pdoc .alert.warning{color:#664d03;background-color:#fff3cd;border-color:#ffecb5;background-image:url("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2224%22%20height%3D%2224%22%20fill%3D%22%23664d03%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M8.982%201.566a1.13%201.13%200%200%200-1.96%200L.165%2013.233c-.457.778.091%201.767.98%201.767h13.713c.889%200%201.438-.99.98-1.767L8.982%201.566zM8%205c.535%200%20.954.462.9.995l-.35%203.507a.552.552%200%200%201-1.1%200L7.1%205.995A.905.905%200%200%201%208%205zm.002%206a1%201%200%201%201%200%202%201%201%200%200%201%200-2z%22/%3E%3C/svg%3E");}.pdoc .alert.danger{color:#842029;background-color:#f8d7da;border-color:#f5c2c7;background-image:url("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2224%22%20height%3D%2224%22%20fill%3D%22%23842029%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M5.52.359A.5.5%200%200%201%206%200h4a.5.5%200%200%201%20.474.658L8.694%206H12.5a.5.5%200%200%201%20.395.807l-7%209a.5.5%200%200%201-.873-.454L6.823%209.5H3.5a.5.5%200%200%201-.48-.641l2.5-8.5z%22/%3E%3C/svg%3E");}.pdoc .visually-hidden{position:absolute !important;width:1px !important;height:1px !important;padding:0 !important;margin:-1px !important;overflow:hidden !important;clip:rect(0, 0, 0, 0) !important;white-space:nowrap !important;border:0 !important;}.pdoc h1, .pdoc h2, .pdoc h3{font-weight:300;margin:.3em 0;padding:.2em 0;}.pdoc > section:not(.module-info) h1{font-size:1.5rem;font-weight:500;}.pdoc > section:not(.module-info) h2{font-size:1.4rem;font-weight:500;}.pdoc > section:not(.module-info) h3{font-size:1.3rem;font-weight:500;}.pdoc > section:not(.module-info) h4{font-size:1.2rem;}.pdoc > section:not(.module-info) h5{font-size:1.1rem;}.pdoc a{text-decoration:none;color:var(--link);}.pdoc a:hover{color:var(--link-hover);}.pdoc blockquote{margin-left:2rem;}.pdoc pre{border-top:1px solid var(--accent2);border-bottom:1px solid var(--accent2);margin-top:0;margin-bottom:1em;padding:.5rem 0 .5rem .5rem;overflow-x:auto;background-color:var(--code);}.pdoc code{color:var(--text);padding:.2em .4em;margin:0;font-size:85%;background-color:var(--accent);border-radius:6px;}.pdoc a > code{color:inherit;}.pdoc pre > code{display:inline-block;font-size:inherit;background:none;border:none;padding:0;}.pdoc > section:not(.module-info){margin-bottom:1.5rem;}.pdoc .modulename{margin-top:0;font-weight:bold;}.pdoc .modulename a{color:var(--link);transition:100ms all;}.pdoc .git-button{float:right;border:solid var(--link) 1px;}.pdoc .git-button:hover{background-color:var(--link);color:var(--pdoc-background);}.view-source-toggle-state,.view-source-toggle-state ~ .pdoc-code{display:none;}.view-source-toggle-state:checked ~ .pdoc-code{display:block;}.view-source-button{display:inline-block;float:right;font-size:.75rem;line-height:1.5rem;color:var(--muted);padding:0 .4rem 0 1.3rem;cursor:pointer;text-indent:-2px;}.view-source-button > span{visibility:hidden;}.module-info .view-source-button{float:none;display:flex;justify-content:flex-end;margin:-1.2rem .4rem -.2rem 0;}.view-source-button::before{position:absolute;content:"View Source";display:list-item;list-style-type:disclosure-closed;}.view-source-toggle-state:checked ~ .attr .view-source-button::before,.view-source-toggle-state:checked ~ .view-source-button::before{list-style-type:disclosure-open;}.pdoc .docstring{margin-bottom:1.5rem;}.pdoc section:not(.module-info) .docstring{margin-left:clamp(0rem, 5vw - 2rem, 1rem);}.pdoc .docstring .pdoc-code{margin-left:1em;margin-right:1em;}.pdoc h1:target,.pdoc h2:target,.pdoc h3:target,.pdoc h4:target,.pdoc h5:target,.pdoc h6:target,.pdoc .pdoc-code > pre > span:target{background-color:var(--active);box-shadow:-1rem 0 0 0 var(--active);}.pdoc .pdoc-code > pre > span:target{display:block;}.pdoc div:target > .attr,.pdoc section:target > .attr,.pdoc dd:target > a{background-color:var(--active);}.pdoc *{scroll-margin:2rem;}.pdoc .pdoc-code .linenos{user-select:none;}.pdoc .attr:hover{filter:contrast(0.95);}.pdoc section, .pdoc .classattr{position:relative;}.pdoc .headerlink{--width:clamp(1rem, 3vw, 2rem);position:absolute;top:0;left:calc(0rem - var(--width));transition:all 100ms ease-in-out;opacity:0;}.pdoc .headerlink::before{content:"#";display:block;text-align:center;width:var(--width);height:2.3rem;line-height:2.3rem;font-size:1.5rem;}.pdoc .attr:hover ~ .headerlink,.pdoc *:target > .headerlink,.pdoc .headerlink:hover{opacity:1;}.pdoc .attr{display:block;margin:.5rem 0 .5rem;padding:.4rem .4rem .4rem 1rem;background-color:var(--accent);overflow-x:auto;}.pdoc .classattr{margin-left:2rem;}.pdoc .decorator-deprecated{color:#842029;}.pdoc .decorator-deprecated ~ span{filter:grayscale(1) opacity(0.8);}.pdoc .name{color:var(--name);font-weight:bold;}.pdoc .def{color:var(--def);font-weight:bold;}.pdoc .signature{background-color:transparent;}.pdoc .param, .pdoc .return-annotation{white-space:pre;}.pdoc .signature.multiline .param{display:block;}.pdoc .signature.condensed .param{display:inline-block;}.pdoc .annotation{color:var(--annotation);}.pdoc .view-value-toggle-state,.pdoc .view-value-toggle-state ~ .default_value{display:none;}.pdoc .view-value-toggle-state:checked ~ .default_value{display:inherit;}.pdoc .view-value-button{font-size:.5rem;vertical-align:middle;border-style:dashed;margin-top:-0.1rem;}.pdoc .view-value-button:hover{background:white;}.pdoc .view-value-button::before{content:"show";text-align:center;width:2.2em;display:inline-block;}.pdoc .view-value-toggle-state:checked ~ .view-value-button::before{content:"hide";}.pdoc .inherited{margin-left:2rem;}.pdoc .inherited dt{font-weight:700;}.pdoc .inherited dt, .pdoc .inherited dd{display:inline;margin-left:0;margin-bottom:.5rem;}.pdoc .inherited dd:not(:last-child):after{content:", ";}.pdoc .inherited .class:before{content:"class ";}.pdoc .inherited .function a:after{content:"()";}.pdoc .search-result .docstring{overflow:auto;max-height:25vh;}.pdoc .search-result.focused > .attr{background-color:var(--active);}.pdoc .attribution{margin-top:2rem;display:block;opacity:0.5;transition:all 200ms;filter:grayscale(100%);}.pdoc .attribution:hover{opacity:1;filter:grayscale(0%);}.pdoc .attribution img{margin-left:5px;height:35px;vertical-align:middle;width:70px;transition:all 200ms;}.pdoc table{display:block;width:max-content;max-width:100%;overflow:auto;margin-bottom:1rem;}.pdoc table th{font-weight:600;}.pdoc table th, .pdoc table td{padding:6px 13px;border:1px solid var(--accent2);}</style>
    <style>/*! custom.css */</style></head>
<body>
    <nav class="pdoc">
        <label id="navtoggle" for="togglestate" class="pdoc-button"><svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'><path stroke-linecap='round' stroke="currentColor" stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/></svg></label>
        <input id="togglestate" type="checkbox" aria-hidden="true" tabindex="-1">
        <div>            <a class="pdoc-button module-list-button" href="../clarena.html">
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-box-arrow-in-left" viewBox="0 0 16 16">
  <path fill-rule="evenodd" d="M10 3.5a.5.5 0 0 0-.5-.5h-8a.5.5 0 0 0-.5.5v9a.5.5 0 0 0 .5.5h8a.5.5 0 0 0 .5-.5v-2a.5.5 0 0 1 1 0v2A1.5 1.5 0 0 1 9.5 14h-8A1.5 1.5 0 0 1 0 12.5v-9A1.5 1.5 0 0 1 1.5 2h8A1.5 1.5 0 0 1 11 3.5v2a.5.5 0 0 1-1 0v-2z"/>
  <path fill-rule="evenodd" d="M4.146 8.354a.5.5 0 0 1 0-.708l3-3a.5.5 0 1 1 .708.708L5.707 7.5H14.5a.5.5 0 0 1 0 1H5.707l2.147 2.146a.5.5 0 0 1-.708.708l-3-3z"/>
</svg>                &nbsp;clarena</a>


            <input type="search" placeholder="Search..." role="searchbox" aria-label="search"
                   pattern=".+" required>

            <h2>Contents</h2>
            <ul>
  <li><a href="#backbone-networks-for-continual-learning">Backbone Networks for Continual Learning</a></li>
</ul>


            <h2>Submodules</h2>
            <ul>
                    <li><a href="backbones/mlp.html">mlp</a></li>
                    <li><a href="backbones/resnet.html">resnet</a></li>
            </ul>

            <h2>API Documentation</h2>
                <ul class="memberlist">
            <li>
                    <a class="class" href="#CLBackbone">CLBackbone</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#CLBackbone.__init__">CLBackbone</a>
                        </li>
                        <li>
                                <a class="variable" href="#CLBackbone.output_dim">output_dim</a>
                        </li>
                        <li>
                                <a class="variable" href="#CLBackbone.weighted_layer_names">weighted_layer_names</a>
                        </li>
                        <li>
                                <a class="variable" href="#CLBackbone.task_id">task_id</a>
                        </li>
                        <li>
                                <a class="function" href="#CLBackbone.setup_task_id">setup_task_id</a>
                        </li>
                        <li>
                                <a class="function" href="#CLBackbone.get_layer_by_name">get_layer_by_name</a>
                        </li>
                        <li>
                                <a class="function" href="#CLBackbone.preceding_layer_name">preceding_layer_name</a>
                        </li>
                        <li>
                                <a class="function" href="#CLBackbone.forward">forward</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#HATMaskBackbone">HATMaskBackbone</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#HATMaskBackbone.__init__">HATMaskBackbone</a>
                        </li>
                        <li>
                                <a class="function" href="#HATMaskBackbone.register_hat_mask_module_explicitly">register_hat_mask_module_explicitly</a>
                        </li>
                        <li>
                                <a class="function" href="#HATMaskBackbone.initialise_task_embedding">initialise_task_embedding</a>
                        </li>
                        <li>
                                <a class="function" href="#HATMaskBackbone.sanity_check">sanity_check</a>
                        </li>
                        <li>
                                <a class="function" href="#HATMaskBackbone.get_mask">get_mask</a>
                        </li>
                        <li>
                                <a class="function" href="#HATMaskBackbone.get_cumulative_mask">get_cumulative_mask</a>
                        </li>
                        <li>
                                <a class="function" href="#HATMaskBackbone.get_summative_mask">get_summative_mask</a>
                        </li>
                        <li>
                                <a class="function" href="#HATMaskBackbone.get_layer_measure_parameter_wise">get_layer_measure_parameter_wise</a>
                        </li>
                        <li>
                                <a class="function" href="#HATMaskBackbone.forward">forward</a>
                        </li>
                </ul>

            </li>
    </ul>



        <a class="attribution" title="pdoc: Python API documentation generator" href="https://pdoc.dev" target="_blank">
            built with <span class="visually-hidden">pdoc</span><img
                alt="pdoc logo"
                src="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20role%3D%22img%22%20aria-label%3D%22pdoc%20logo%22%20width%3D%22300%22%20height%3D%22150%22%20viewBox%3D%22-1%200%2060%2030%22%3E%3Ctitle%3Epdoc%3C/title%3E%3Cpath%20d%3D%22M29.621%2021.293c-.011-.273-.214-.475-.511-.481a.5.5%200%200%200-.489.503l-.044%201.393c-.097.551-.695%201.215-1.566%201.704-.577.428-1.306.486-2.193.182-1.426-.617-2.467-1.654-3.304-2.487l-.173-.172a3.43%203.43%200%200%200-.365-.306.49.49%200%200%200-.286-.196c-1.718-1.06-4.931-1.47-7.353.191l-.219.15c-1.707%201.187-3.413%202.131-4.328%201.03-.02-.027-.49-.685-.141-1.763.233-.721.546-2.408.772-4.076.042-.09.067-.187.046-.288.166-1.347.277-2.625.241-3.351%201.378-1.008%202.271-2.586%202.271-4.362%200-.976-.272-1.935-.788-2.774-.057-.094-.122-.18-.184-.268.033-.167.052-.339.052-.516%200-1.477-1.202-2.679-2.679-2.679-.791%200-1.496.352-1.987.9a6.3%206.3%200%200%200-1.001.029c-.492-.564-1.207-.929-2.012-.929-1.477%200-2.679%201.202-2.679%202.679A2.65%202.65%200%200%200%20.97%206.554c-.383.747-.595%201.572-.595%202.41%200%202.311%201.507%204.29%203.635%205.107-.037.699-.147%202.27-.423%203.294l-.137.461c-.622%202.042-2.515%208.257%201.727%2010.643%201.614.908%203.06%201.248%204.317%201.248%202.665%200%204.492-1.524%205.322-2.401%201.476-1.559%202.886-1.854%206.491.82%201.877%201.393%203.514%201.753%204.861%201.068%202.223-1.713%202.811-3.867%203.399-6.374.077-.846.056-1.469.054-1.537zm-4.835%204.313c-.054.305-.156.586-.242.629-.034-.007-.131-.022-.307-.157-.145-.111-.314-.478-.456-.908.221.121.432.25.675.355.115.039.219.051.33.081zm-2.251-1.238c-.05.33-.158.648-.252.694-.022.001-.125-.018-.307-.157-.217-.166-.488-.906-.639-1.573.358.344.754.693%201.198%201.036zm-3.887-2.337c-.006-.116-.018-.231-.041-.342.635.145%201.189.368%201.599.625.097.231.166.481.174.642-.03.049-.055.101-.067.158-.046.013-.128.026-.298.004-.278-.037-.901-.57-1.367-1.087zm-1.127-.497c.116.306.176.625.12.71-.019.014-.117.045-.345.016-.206-.027-.604-.332-.986-.695.41-.051.816-.056%201.211-.031zm-4.535%201.535c.209.22.379.47.358.598-.006.041-.088.138-.351.234-.144.055-.539-.063-.979-.259a11.66%2011.66%200%200%200%20.972-.573zm.983-.664c.359-.237.738-.418%201.126-.554.25.237.479.548.457.694-.006.042-.087.138-.351.235-.174.064-.694-.105-1.232-.375zm-3.381%201.794c-.022.145-.061.29-.149.401-.133.166-.358.248-.69.251h-.002c-.133%200-.306-.26-.45-.621.417.091.854.07%201.291-.031zm-2.066-8.077a4.78%204.78%200%200%201-.775-.584c.172-.115.505-.254.88-.378l-.105.962zm-.331%202.302a10.32%2010.32%200%200%201-.828-.502c.202-.143.576-.328.984-.49l-.156.992zm-.45%202.157l-.701-.403c.214-.115.536-.249.891-.376a11.57%2011.57%200%200%201-.19.779zm-.181%201.716c.064.398.194.702.298.893-.194-.051-.435-.162-.736-.398.061-.119.224-.3.438-.495zM8.87%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zm-.735-.389a1.15%201.15%200%200%200-.314.783%201.16%201.16%200%200%200%201.162%201.162c.457%200%20.842-.27%201.032-.653.026.117.042.238.042.362a1.68%201.68%200%200%201-1.679%201.679%201.68%201.68%200%200%201-1.679-1.679c0-.843.626-1.535%201.436-1.654zM5.059%205.406A1.68%201.68%200%200%201%203.38%207.085a1.68%201.68%200%200%201-1.679-1.679c0-.037.009-.072.011-.109.21.3.541.508.935.508a1.16%201.16%200%200%200%201.162-1.162%201.14%201.14%200%200%200-.474-.912c.015%200%20.03-.005.045-.005.926.001%201.679.754%201.679%201.68zM3.198%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zM1.375%208.964c0-.52.103-1.035.288-1.52.466.394%201.06.64%201.717.64%201.144%200%202.116-.725%202.499-1.738.383%201.012%201.355%201.738%202.499%201.738.867%200%201.631-.421%202.121-1.062.307.605.478%201.267.478%201.942%200%202.486-2.153%204.51-4.801%204.51s-4.801-2.023-4.801-4.51zm24.342%2019.349c-.985.498-2.267.168-3.813-.979-3.073-2.281-5.453-3.199-7.813-.705-1.315%201.391-4.163%203.365-8.423.97-3.174-1.786-2.239-6.266-1.261-9.479l.146-.492c.276-1.02.395-2.457.444-3.268a6.11%206.11%200%200%200%201.18.115%206.01%206.01%200%200%200%202.536-.562l-.006.175c-.802.215-1.848.612-2.021%201.25-.079.295.021.601.274.837.219.203.415.364.598.501-.667.304-1.243.698-1.311%201.179-.02.144-.022.507.393.787.213.144.395.26.564.365-1.285.521-1.361.96-1.381%201.126-.018.142-.011.496.427.746l.854.489c-.473.389-.971.914-.999%201.429-.018.278.095.532.316.713.675.556%201.231.721%201.653.721.059%200%20.104-.014.158-.02.207.707.641%201.64%201.513%201.64h.013c.8-.008%201.236-.345%201.462-.626.173-.216.268-.457.325-.692.424.195.93.374%201.372.374.151%200%20.294-.021.423-.068.732-.27.944-.704.993-1.021.009-.061.003-.119.002-.179.266.086.538.147.789.147.15%200%20.294-.021.423-.069.542-.2.797-.489.914-.754.237.147.478.258.704.288.106.014.205.021.296.021.356%200%20.595-.101.767-.229.438.435%201.094.992%201.656%201.067.106.014.205.021.296.021a1.56%201.56%200%200%200%20.323-.035c.17.575.453%201.289.866%201.605.358.273.665.362.914.362a.99.99%200%200%200%20.421-.093%201.03%201.03%200%200%200%20.245-.164c.168.428.39.846.68%201.068.358.273.665.362.913.362a.99.99%200%200%200%20.421-.093c.317-.148.512-.448.639-.762.251.157.495.257.726.257.127%200%20.25-.024.37-.071.427-.17.706-.617.841-1.314.022-.015.047-.022.068-.038.067-.051.133-.104.196-.159-.443%201.486-1.107%202.761-2.086%203.257zM8.66%209.925a.5.5%200%201%200-1%200c0%20.653-.818%201.205-1.787%201.205s-1.787-.552-1.787-1.205a.5.5%200%201%200-1%200c0%201.216%201.25%202.205%202.787%202.205s2.787-.989%202.787-2.205zm4.4%2015.965l-.208.097c-2.661%201.258-4.708%201.436-6.086.527-1.542-1.017-1.88-3.19-1.844-4.198a.4.4%200%200%200-.385-.414c-.242-.029-.406.164-.414.385-.046%201.249.367%203.686%202.202%204.896.708.467%201.547.7%202.51.7%201.248%200%202.706-.392%204.362-1.174l.185-.086a.4.4%200%200%200%20.205-.527c-.089-.204-.326-.291-.527-.206zM9.547%202.292c.093.077.205.114.317.114a.5.5%200%200%200%20.318-.886L8.817.397a.5.5%200%200%200-.703.068.5.5%200%200%200%20.069.703l1.364%201.124zm-7.661-.065c.086%200%20.173-.022.253-.068l1.523-.893a.5.5%200%200%200-.506-.863l-1.523.892a.5.5%200%200%200-.179.685c.094.158.261.247.432.247z%22%20transform%3D%22matrix%28-1%200%200%201%2058%200%29%22%20fill%3D%22%233bb300%22/%3E%3Cpath%20d%3D%22M.3%2021.86V10.18q0-.46.02-.68.04-.22.18-.5.28-.54%201.34-.54%201.06%200%201.42.28.38.26.44.78.76-1.04%202.38-1.04%201.64%200%203.1%201.54%201.46%201.54%201.46%203.58%200%202.04-1.46%203.58-1.44%201.54-3.08%201.54-1.64%200-2.38-.92v4.04q0%20.46-.04.68-.02.22-.18.5-.14.3-.5.42-.36.12-.98.12-.62%200-1-.12-.36-.12-.52-.4-.14-.28-.18-.5-.02-.22-.02-.68zm3.96-9.42q-.46.54-.46%201.18%200%20.64.46%201.18.48.52%201.2.52.74%200%201.24-.52.52-.52.52-1.18%200-.66-.48-1.18-.48-.54-1.26-.54-.76%200-1.22.54zm14.741-8.36q.16-.3.54-.42.38-.12%201-.12.64%200%201.02.12.38.12.52.42.16.3.18.54.04.22.04.68v11.94q0%20.46-.04.7-.02.22-.18.5-.3.54-1.7.54-1.38%200-1.54-.98-.84.96-2.34.96-1.8%200-3.28-1.56-1.48-1.58-1.48-3.66%200-2.1%201.48-3.68%201.5-1.58%203.28-1.58%201.48%200%202.3%201v-4.2q0-.46.02-.68.04-.24.18-.52zm-3.24%2010.86q.52.54%201.26.54.74%200%201.22-.54.5-.54.5-1.18%200-.66-.48-1.22-.46-.56-1.26-.56-.8%200-1.28.56-.48.54-.48%201.2%200%20.66.52%201.2zm7.833-1.2q0-2.4%201.68-3.96%201.68-1.56%203.84-1.56%202.16%200%203.82%201.56%201.66%201.54%201.66%203.94%200%201.66-.86%202.96-.86%201.28-2.1%201.9-1.22.6-2.54.6-1.32%200-2.56-.64-1.24-.66-2.1-1.92-.84-1.28-.84-2.88zm4.18%201.44q.64.48%201.3.48.66%200%201.32-.5.66-.5.66-1.48%200-.98-.62-1.46-.62-.48-1.34-.48-.72%200-1.34.5-.62.5-.62%201.48%200%20.96.64%201.46zm11.412-1.44q0%20.84.56%201.32.56.46%201.18.46.64%200%201.18-.36.56-.38.9-.38.6%200%201.46%201.06.46.58.46%201.04%200%20.76-1.1%201.42-1.14.8-2.8.8-1.86%200-3.58-1.34-.82-.64-1.34-1.7-.52-1.08-.52-2.36%200-1.3.52-2.34.52-1.06%201.34-1.7%201.66-1.32%203.54-1.32.76%200%201.48.22.72.2%201.06.4l.32.2q.36.24.56.38.52.4.52.92%200%20.5-.42%201.14-.72%201.1-1.38%201.1-.38%200-1.08-.44-.36-.34-1.04-.34-.66%200-1.24.48-.58.48-.58%201.34z%22%20fill%3D%22green%22/%3E%3C/svg%3E"/>
        </a>
</div>
    </nav>
    <main class="pdoc">
            <section class="module-info">
                    <h1 class="modulename">
<a href="./../clarena.html">clarena</a><wbr>.backbones    </h1>

                        <div class="docstring"><h1 id="backbone-networks-for-continual-learning">Backbone Networks for Continual Learning</h1>

<p>This submodule provides the <strong>backbone neural network architectures for continual learning</strong>. </p>

<p>Please note that this is an API documentation. Please refer to the main documentation pages for more information about the backbone networks and how to 
configure and implement them:</p>

<ul>
<li><a href="https://pengxiang-wang.com/projects/continual-learning-arena/docs/configure-your-experiment/backbone-network"><strong>Configure Backbone Network</strong></a></li>
<li><a href="https://pengxiang-wang.com/projects/continual-learning-arena/docs/implement-your-CL-modules/backbone-network"><strong>Implement Your CL Backbone Class</strong></a></li>
</ul>

<p>The backbones are implemented as subclasses of <code><a href="#CLBackbone">CLBackbone</a></code> classes, which are the base class for all continual learning backbones in CLArena.</p>

<ul>
<li><code><a href="#CLBackbone">CLBackbone</a></code>: The base class for continual learning backbones.</li>
<li><code><a href="#HATMaskBackbone">HATMaskBackbone</a></code>: The base class for backbones used in <a href="http://proceedings.mlr.press/v80/serra18a">HAT (Hard Attention to the Task) algorithm</a>. A child class of <code><a href="#CLBackbone">CLBackbone</a></code>.</li>
</ul>
</div>

                        <input id="mod-backbones-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">

                        <label class="view-source-button" for="mod-backbones-view-source"><span>View Source</span></label>

                        <div class="pdoc-code codehilite"><pre><span></span><span id="L-1"><a href="#L-1"><span class="linenos"> 1</span></a><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="L-2"><a href="#L-2"><span class="linenos"> 2</span></a>
</span><span id="L-3"><a href="#L-3"><span class="linenos"> 3</span></a><span class="sd"># Backbone Networks for Continual Learning</span>
</span><span id="L-4"><a href="#L-4"><span class="linenos"> 4</span></a>
</span><span id="L-5"><a href="#L-5"><span class="linenos"> 5</span></a><span class="sd">This submodule provides the **backbone neural network architectures for continual learning**. </span>
</span><span id="L-6"><a href="#L-6"><span class="linenos"> 6</span></a>
</span><span id="L-7"><a href="#L-7"><span class="linenos"> 7</span></a><span class="sd">Please note that this is an API documentation. Please refer to the main documentation pages for more information about the backbone networks and how to </span>
</span><span id="L-8"><a href="#L-8"><span class="linenos"> 8</span></a><span class="sd">configure and implement them:</span>
</span><span id="L-9"><a href="#L-9"><span class="linenos"> 9</span></a>
</span><span id="L-10"><a href="#L-10"><span class="linenos">10</span></a><span class="sd">- [**Configure Backbone Network**](https://pengxiang-wang.com/projects/continual-learning-arena/docs/configure-your-experiment/backbone-network)</span>
</span><span id="L-11"><a href="#L-11"><span class="linenos">11</span></a><span class="sd">- [**Implement Your CL Backbone Class**](https://pengxiang-wang.com/projects/continual-learning-arena/docs/implement-your-CL-modules/backbone-network)</span>
</span><span id="L-12"><a href="#L-12"><span class="linenos">12</span></a>
</span><span id="L-13"><a href="#L-13"><span class="linenos">13</span></a>
</span><span id="L-14"><a href="#L-14"><span class="linenos">14</span></a>
</span><span id="L-15"><a href="#L-15"><span class="linenos">15</span></a><span class="sd">The backbones are implemented as subclasses of `CLBackbone` classes, which are the base class for all continual learning backbones in CLArena.</span>
</span><span id="L-16"><a href="#L-16"><span class="linenos">16</span></a>
</span><span id="L-17"><a href="#L-17"><span class="linenos">17</span></a><span class="sd">- `CLBackbone`: The base class for continual learning backbones.</span>
</span><span id="L-18"><a href="#L-18"><span class="linenos">18</span></a><span class="sd">- `HATMaskBackbone`: The base class for backbones used in [HAT (Hard Attention to the Task) algorithm](http://proceedings.mlr.press/v80/serra18a). A child class of `CLBackbone`.</span>
</span><span id="L-19"><a href="#L-19"><span class="linenos">19</span></a>
</span><span id="L-20"><a href="#L-20"><span class="linenos">20</span></a>
</span><span id="L-21"><a href="#L-21"><span class="linenos">21</span></a><span class="sd">&quot;&quot;&quot;</span>
</span><span id="L-22"><a href="#L-22"><span class="linenos">22</span></a>
</span><span id="L-23"><a href="#L-23"><span class="linenos">23</span></a><span class="kn">from</span><span class="w"> </span><span class="nn">.base</span><span class="w"> </span><span class="kn">import</span> <span class="n">CLBackbone</span><span class="p">,</span> <span class="n">HATMaskBackbone</span>
</span><span id="L-24"><a href="#L-24"><span class="linenos">24</span></a><span class="kn">from</span><span class="w"> </span><span class="nn">.mlp</span><span class="w"> </span><span class="kn">import</span> <span class="n">MLP</span><span class="p">,</span> <span class="n">HATMaskMLP</span>
</span><span id="L-25"><a href="#L-25"><span class="linenos">25</span></a><span class="kn">from</span><span class="w"> </span><span class="nn">.resnet</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
</span><span id="L-26"><a href="#L-26"><span class="linenos">26</span></a>    <span class="n">HATMaskResNet18</span><span class="p">,</span>
</span><span id="L-27"><a href="#L-27"><span class="linenos">27</span></a>    <span class="n">HATMaskResNet34</span><span class="p">,</span>
</span><span id="L-28"><a href="#L-28"><span class="linenos">28</span></a>    <span class="n">HATMaskResNet50</span><span class="p">,</span>
</span><span id="L-29"><a href="#L-29"><span class="linenos">29</span></a>    <span class="n">HATMaskResNet101</span><span class="p">,</span>
</span><span id="L-30"><a href="#L-30"><span class="linenos">30</span></a>    <span class="n">HATMaskResNet152</span><span class="p">,</span>
</span><span id="L-31"><a href="#L-31"><span class="linenos">31</span></a>    <span class="n">ResNet18</span><span class="p">,</span>
</span><span id="L-32"><a href="#L-32"><span class="linenos">32</span></a>    <span class="n">ResNet34</span><span class="p">,</span>
</span><span id="L-33"><a href="#L-33"><span class="linenos">33</span></a>    <span class="n">ResNet50</span><span class="p">,</span>
</span><span id="L-34"><a href="#L-34"><span class="linenos">34</span></a>    <span class="n">ResNet101</span><span class="p">,</span>
</span><span id="L-35"><a href="#L-35"><span class="linenos">35</span></a>    <span class="n">ResNet152</span><span class="p">,</span>
</span><span id="L-36"><a href="#L-36"><span class="linenos">36</span></a><span class="p">)</span>
</span><span id="L-37"><a href="#L-37"><span class="linenos">37</span></a>
</span><span id="L-38"><a href="#L-38"><span class="linenos">38</span></a><span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;CLBackbone&quot;</span><span class="p">,</span> <span class="s2">&quot;HATMaskBackbone&quot;</span><span class="p">,</span> <span class="s2">&quot;mlp&quot;</span><span class="p">,</span> <span class="s2">&quot;resnet&quot;</span><span class="p">]</span>
</span></pre></div>


            </section>
                <section id="CLBackbone">
                            <input id="CLBackbone-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr class">
            
    <span class="def">class</span>
    <span class="name">CLBackbone</span><wbr>(<span class="base">torch.nn.modules.module.Module</span>):

                <label class="view-source-button" for="CLBackbone-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#CLBackbone"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="CLBackbone-18"><a href="#CLBackbone-18"><span class="linenos"> 18</span></a><span class="k">class</span><span class="w"> </span><span class="nc">CLBackbone</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
</span><span id="CLBackbone-19"><a href="#CLBackbone-19"><span class="linenos"> 19</span></a><span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;The base class of continual learning backbone networks, inherited from `nn.Module`.&quot;&quot;&quot;</span>
</span><span id="CLBackbone-20"><a href="#CLBackbone-20"><span class="linenos"> 20</span></a>
</span><span id="CLBackbone-21"><a href="#CLBackbone-21"><span class="linenos"> 21</span></a>    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_dim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="CLBackbone-22"><a href="#CLBackbone-22"><span class="linenos"> 22</span></a><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Initialise the CL backbone network.</span>
</span><span id="CLBackbone-23"><a href="#CLBackbone-23"><span class="linenos"> 23</span></a>
</span><span id="CLBackbone-24"><a href="#CLBackbone-24"><span class="linenos"> 24</span></a><span class="sd">        **Args:**</span>
</span><span id="CLBackbone-25"><a href="#CLBackbone-25"><span class="linenos"> 25</span></a><span class="sd">        - **output_dim** (`int` | `None`): The output dimension which connects to CL output heads. The `input_dim` of output heads are expected to be the same as this `output_dim`. In some cases, this class is used for a block in the backbone network, which doesn&#39;t have the output dimension. In this case, it can be `None`.</span>
</span><span id="CLBackbone-26"><a href="#CLBackbone-26"><span class="linenos"> 26</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="CLBackbone-27"><a href="#CLBackbone-27"><span class="linenos"> 27</span></a>        <span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</span><span id="CLBackbone-28"><a href="#CLBackbone-28"><span class="linenos"> 28</span></a>
</span><span id="CLBackbone-29"><a href="#CLBackbone-29"><span class="linenos"> 29</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">output_dim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">output_dim</span>
</span><span id="CLBackbone-30"><a href="#CLBackbone-30"><span class="linenos"> 30</span></a><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Store the output dimension of the backbone network.&quot;&quot;&quot;</span>
</span><span id="CLBackbone-31"><a href="#CLBackbone-31"><span class="linenos"> 31</span></a>
</span><span id="CLBackbone-32"><a href="#CLBackbone-32"><span class="linenos"> 32</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">weighted_layer_names</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
</span><span id="CLBackbone-33"><a href="#CLBackbone-33"><span class="linenos"> 33</span></a><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Maintain a list of the weighted layer names. Weighted layer has weights connecting to other weighted layer. They are the main part of neural networks. **It must be provided in subclasses.**</span>
</span><span id="CLBackbone-34"><a href="#CLBackbone-34"><span class="linenos"> 34</span></a><span class="sd">        </span>
</span><span id="CLBackbone-35"><a href="#CLBackbone-35"><span class="linenos"> 35</span></a><span class="sd">        The names are following the `nn.Module` internal naming mechanism. For example, if the a layer is assigned to `self.conv1`, the name becomes `conv1`. If the `nn.Sequential` is used, the name becomes the index of the layer in the sequence, such as `0`, `1`, etc. If hierarchical structure is used, for example, a `nn.Module` is assigned to `self.block` which has `self.conv1`, the name becomes `block/conv1`. Note that it should be `block.conv1` according to `nn.Module` internal mechanism, but we use &#39;/&#39; instead of &#39;.&#39; to avoid the error of using &#39;.&#39; in the key of `ModuleDict`.</span>
</span><span id="CLBackbone-36"><a href="#CLBackbone-36"><span class="linenos"> 36</span></a><span class="sd">        </span>
</span><span id="CLBackbone-37"><a href="#CLBackbone-37"><span class="linenos"> 37</span></a><span class="sd">        In HAT architecture, it&#39;s also the layer names with task embedding masking in the order of forward pass. HAT gives task embedding to every possible weighted layer. </span>
</span><span id="CLBackbone-38"><a href="#CLBackbone-38"><span class="linenos"> 38</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="CLBackbone-39"><a href="#CLBackbone-39"><span class="linenos"> 39</span></a>
</span><span id="CLBackbone-40"><a href="#CLBackbone-40"><span class="linenos"> 40</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">task_id</span><span class="p">:</span> <span class="nb">int</span>
</span><span id="CLBackbone-41"><a href="#CLBackbone-41"><span class="linenos"> 41</span></a><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Task ID counter indicating which task is being processed. Self updated during the task loop.&quot;&quot;&quot;</span>
</span><span id="CLBackbone-42"><a href="#CLBackbone-42"><span class="linenos"> 42</span></a>
</span><span id="CLBackbone-43"><a href="#CLBackbone-43"><span class="linenos"> 43</span></a>    <span class="k">def</span><span class="w"> </span><span class="nf">setup_task_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="CLBackbone-44"><a href="#CLBackbone-44"><span class="linenos"> 44</span></a><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Set up which task&#39;s dataset the CL experiment is on. This must be done before `forward()` method is called.</span>
</span><span id="CLBackbone-45"><a href="#CLBackbone-45"><span class="linenos"> 45</span></a>
</span><span id="CLBackbone-46"><a href="#CLBackbone-46"><span class="linenos"> 46</span></a><span class="sd">        **Args:**</span>
</span><span id="CLBackbone-47"><a href="#CLBackbone-47"><span class="linenos"> 47</span></a><span class="sd">        - **task_id** (`int`): the target task ID.</span>
</span><span id="CLBackbone-48"><a href="#CLBackbone-48"><span class="linenos"> 48</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="CLBackbone-49"><a href="#CLBackbone-49"><span class="linenos"> 49</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">task_id</span> <span class="o">=</span> <span class="n">task_id</span>
</span><span id="CLBackbone-50"><a href="#CLBackbone-50"><span class="linenos"> 50</span></a>
</span><span id="CLBackbone-51"><a href="#CLBackbone-51"><span class="linenos"> 51</span></a>    <span class="k">def</span><span class="w"> </span><span class="nf">get_layer_by_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">:</span>
</span><span id="CLBackbone-52"><a href="#CLBackbone-52"><span class="linenos"> 52</span></a><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Get the layer by its name.</span>
</span><span id="CLBackbone-53"><a href="#CLBackbone-53"><span class="linenos"> 53</span></a>
</span><span id="CLBackbone-54"><a href="#CLBackbone-54"><span class="linenos"> 54</span></a><span class="sd">        **Args:**</span>
</span><span id="CLBackbone-55"><a href="#CLBackbone-55"><span class="linenos"> 55</span></a><span class="sd">        - **layer_name** (`str`): the name of the layer. Note that the name is the name substituting the &#39;.&#39; with &#39;/&#39;, like `block/conv1`, rather than `block.conv1`.</span>
</span><span id="CLBackbone-56"><a href="#CLBackbone-56"><span class="linenos"> 56</span></a>
</span><span id="CLBackbone-57"><a href="#CLBackbone-57"><span class="linenos"> 57</span></a><span class="sd">        **Returns:**</span>
</span><span id="CLBackbone-58"><a href="#CLBackbone-58"><span class="linenos"> 58</span></a><span class="sd">        - **layer** (`nn.Module`): the layer.</span>
</span><span id="CLBackbone-59"><a href="#CLBackbone-59"><span class="linenos"> 59</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="CLBackbone-60"><a href="#CLBackbone-60"><span class="linenos"> 60</span></a>        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">layer</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">named_modules</span><span class="p">():</span>
</span><span id="CLBackbone-61"><a href="#CLBackbone-61"><span class="linenos"> 61</span></a>            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="n">layer_name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="s2">&quot;.&quot;</span><span class="p">):</span>
</span><span id="CLBackbone-62"><a href="#CLBackbone-62"><span class="linenos"> 62</span></a>                <span class="k">return</span> <span class="n">layer</span>
</span><span id="CLBackbone-63"><a href="#CLBackbone-63"><span class="linenos"> 63</span></a>
</span><span id="CLBackbone-64"><a href="#CLBackbone-64"><span class="linenos"> 64</span></a>    <span class="k">def</span><span class="w"> </span><span class="nf">preceding_layer_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
</span><span id="CLBackbone-65"><a href="#CLBackbone-65"><span class="linenos"> 65</span></a><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Get the name of the preceding layer of the given layer from the stored `self.masked_layer_order`. If the given layer is the first layer, return `None`.</span>
</span><span id="CLBackbone-66"><a href="#CLBackbone-66"><span class="linenos"> 66</span></a>
</span><span id="CLBackbone-67"><a href="#CLBackbone-67"><span class="linenos"> 67</span></a><span class="sd">        **Args:**</span>
</span><span id="CLBackbone-68"><a href="#CLBackbone-68"><span class="linenos"> 68</span></a><span class="sd">        - **layer_name** (`str`): the name of the layer.</span>
</span><span id="CLBackbone-69"><a href="#CLBackbone-69"><span class="linenos"> 69</span></a>
</span><span id="CLBackbone-70"><a href="#CLBackbone-70"><span class="linenos"> 70</span></a><span class="sd">        **Returns:**</span>
</span><span id="CLBackbone-71"><a href="#CLBackbone-71"><span class="linenos"> 71</span></a><span class="sd">        - **preceding_layer_name** (`str`): the name of the preceding layer.</span>
</span><span id="CLBackbone-72"><a href="#CLBackbone-72"><span class="linenos"> 72</span></a>
</span><span id="CLBackbone-73"><a href="#CLBackbone-73"><span class="linenos"> 73</span></a><span class="sd">        **Raises:**</span>
</span><span id="CLBackbone-74"><a href="#CLBackbone-74"><span class="linenos"> 74</span></a><span class="sd">        - **ValueError**: if `layer_name` is not in the weighted layer order.</span>
</span><span id="CLBackbone-75"><a href="#CLBackbone-75"><span class="linenos"> 75</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="CLBackbone-76"><a href="#CLBackbone-76"><span class="linenos"> 76</span></a>
</span><span id="CLBackbone-77"><a href="#CLBackbone-77"><span class="linenos"> 77</span></a>        <span class="k">if</span> <span class="n">layer_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted_layer_names</span><span class="p">:</span>
</span><span id="CLBackbone-78"><a href="#CLBackbone-78"><span class="linenos"> 78</span></a>            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The layer name </span><span class="si">{</span><span class="n">layer_name</span><span class="si">}</span><span class="s2"> doesn&#39;t exist.&quot;</span><span class="p">)</span>
</span><span id="CLBackbone-79"><a href="#CLBackbone-79"><span class="linenos"> 79</span></a>
</span><span id="CLBackbone-80"><a href="#CLBackbone-80"><span class="linenos"> 80</span></a>        <span class="n">weighted_layer_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted_layer_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">layer_name</span><span class="p">)</span>
</span><span id="CLBackbone-81"><a href="#CLBackbone-81"><span class="linenos"> 81</span></a>        <span class="k">if</span> <span class="n">weighted_layer_idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span><span id="CLBackbone-82"><a href="#CLBackbone-82"><span class="linenos"> 82</span></a>            <span class="k">return</span> <span class="kc">None</span>
</span><span id="CLBackbone-83"><a href="#CLBackbone-83"><span class="linenos"> 83</span></a>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted_layer_names</span><span class="p">[</span><span class="n">weighted_layer_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
</span><span id="CLBackbone-84"><a href="#CLBackbone-84"><span class="linenos"> 84</span></a>
</span><span id="CLBackbone-85"><a href="#CLBackbone-85"><span class="linenos"> 85</span></a>    <span class="nd">@override</span>  <span class="c1"># since `nn.Module` uses it</span>
</span><span id="CLBackbone-86"><a href="#CLBackbone-86"><span class="linenos"> 86</span></a>    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span>
</span><span id="CLBackbone-87"><a href="#CLBackbone-87"><span class="linenos"> 87</span></a>        <span class="bp">self</span><span class="p">,</span>
</span><span id="CLBackbone-88"><a href="#CLBackbone-88"><span class="linenos"> 88</span></a>        <span class="nb">input</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
</span><span id="CLBackbone-89"><a href="#CLBackbone-89"><span class="linenos"> 89</span></a>        <span class="n">stage</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
</span><span id="CLBackbone-90"><a href="#CLBackbone-90"><span class="linenos"> 90</span></a>        <span class="n">task_id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
</span><span id="CLBackbone-91"><a href="#CLBackbone-91"><span class="linenos"> 91</span></a>    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]]:</span>
</span><span id="CLBackbone-92"><a href="#CLBackbone-92"><span class="linenos"> 92</span></a><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;The forward pass for data from task `task_id`. In some backbones, the forward pass might be different for different tasks. **It must be implemented by subclasses.**</span>
</span><span id="CLBackbone-93"><a href="#CLBackbone-93"><span class="linenos"> 93</span></a>
</span><span id="CLBackbone-94"><a href="#CLBackbone-94"><span class="linenos"> 94</span></a><span class="sd">        **Args:**</span>
</span><span id="CLBackbone-95"><a href="#CLBackbone-95"><span class="linenos"> 95</span></a><span class="sd">        - **input** (`Tensor`): The input tensor from data.</span>
</span><span id="CLBackbone-96"><a href="#CLBackbone-96"><span class="linenos"> 96</span></a><span class="sd">        - **stage** (`str`): the stage of the forward pass, should be one of the following:</span>
</span><span id="CLBackbone-97"><a href="#CLBackbone-97"><span class="linenos"> 97</span></a><span class="sd">            1. &#39;train&#39;: training stage.</span>
</span><span id="CLBackbone-98"><a href="#CLBackbone-98"><span class="linenos"> 98</span></a><span class="sd">            2. &#39;validation&#39;: validation stage.</span>
</span><span id="CLBackbone-99"><a href="#CLBackbone-99"><span class="linenos"> 99</span></a><span class="sd">            3. &#39;test&#39;: testing stage.</span>
</span><span id="CLBackbone-100"><a href="#CLBackbone-100"><span class="linenos">100</span></a><span class="sd">        - **task_id** (`int` | `None`): the task ID where the data are from. If stage is &#39;train&#39; or &#39;validation&#39;, it is usually from the current task `self.task_id`. If stage is &#39;test&#39;, it could be from any seen task. In TIL, the task IDs of test data are provided thus this argument can be used. In CIL, they are not provided, so it is just a placeholder for API consistence but never used, and best practices are not to provide this argument and leave it as the default value.</span>
</span><span id="CLBackbone-101"><a href="#CLBackbone-101"><span class="linenos">101</span></a>
</span><span id="CLBackbone-102"><a href="#CLBackbone-102"><span class="linenos">102</span></a><span class="sd">        **Returns:**</span>
</span><span id="CLBackbone-103"><a href="#CLBackbone-103"><span class="linenos">103</span></a><span class="sd">        - **output_feature** (`Tensor`): the output feature tensor to be passed into heads. This is the main target of backpropagation.</span>
</span><span id="CLBackbone-104"><a href="#CLBackbone-104"><span class="linenos">104</span></a><span class="sd">        - **activations** (`dict[str, Tensor]`): the hidden features (after activation) in each weighted layer. Key (`str`) is the weighted layer name, value (`Tensor`) is the hidden feature tensor. This is used for the continual learning algorithms that need to use the hidden features for various purposes.</span>
</span><span id="CLBackbone-105"><a href="#CLBackbone-105"><span class="linenos">105</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span></pre></div>


            <div class="docstring"><p>The base class of continual learning backbone networks, inherited from <code>nn.Module</code>.</p>
</div>


                            <div id="CLBackbone.__init__" class="classattr">
                                        <input id="CLBackbone.__init__-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="name">CLBackbone</span><span class="signature pdoc-code condensed">(<span class="param"><span class="n">output_dim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span></span>)</span>

                <label class="view-source-button" for="CLBackbone.__init__-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#CLBackbone.__init__"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="CLBackbone.__init__-21"><a href="#CLBackbone.__init__-21"><span class="linenos">21</span></a>    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_dim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="CLBackbone.__init__-22"><a href="#CLBackbone.__init__-22"><span class="linenos">22</span></a><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Initialise the CL backbone network.</span>
</span><span id="CLBackbone.__init__-23"><a href="#CLBackbone.__init__-23"><span class="linenos">23</span></a>
</span><span id="CLBackbone.__init__-24"><a href="#CLBackbone.__init__-24"><span class="linenos">24</span></a><span class="sd">        **Args:**</span>
</span><span id="CLBackbone.__init__-25"><a href="#CLBackbone.__init__-25"><span class="linenos">25</span></a><span class="sd">        - **output_dim** (`int` | `None`): The output dimension which connects to CL output heads. The `input_dim` of output heads are expected to be the same as this `output_dim`. In some cases, this class is used for a block in the backbone network, which doesn&#39;t have the output dimension. In this case, it can be `None`.</span>
</span><span id="CLBackbone.__init__-26"><a href="#CLBackbone.__init__-26"><span class="linenos">26</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="CLBackbone.__init__-27"><a href="#CLBackbone.__init__-27"><span class="linenos">27</span></a>        <span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</span><span id="CLBackbone.__init__-28"><a href="#CLBackbone.__init__-28"><span class="linenos">28</span></a>
</span><span id="CLBackbone.__init__-29"><a href="#CLBackbone.__init__-29"><span class="linenos">29</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">output_dim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">output_dim</span>
</span><span id="CLBackbone.__init__-30"><a href="#CLBackbone.__init__-30"><span class="linenos">30</span></a><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Store the output dimension of the backbone network.&quot;&quot;&quot;</span>
</span><span id="CLBackbone.__init__-31"><a href="#CLBackbone.__init__-31"><span class="linenos">31</span></a>
</span><span id="CLBackbone.__init__-32"><a href="#CLBackbone.__init__-32"><span class="linenos">32</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">weighted_layer_names</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
</span><span id="CLBackbone.__init__-33"><a href="#CLBackbone.__init__-33"><span class="linenos">33</span></a><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Maintain a list of the weighted layer names. Weighted layer has weights connecting to other weighted layer. They are the main part of neural networks. **It must be provided in subclasses.**</span>
</span><span id="CLBackbone.__init__-34"><a href="#CLBackbone.__init__-34"><span class="linenos">34</span></a><span class="sd">        </span>
</span><span id="CLBackbone.__init__-35"><a href="#CLBackbone.__init__-35"><span class="linenos">35</span></a><span class="sd">        The names are following the `nn.Module` internal naming mechanism. For example, if the a layer is assigned to `self.conv1`, the name becomes `conv1`. If the `nn.Sequential` is used, the name becomes the index of the layer in the sequence, such as `0`, `1`, etc. If hierarchical structure is used, for example, a `nn.Module` is assigned to `self.block` which has `self.conv1`, the name becomes `block/conv1`. Note that it should be `block.conv1` according to `nn.Module` internal mechanism, but we use &#39;/&#39; instead of &#39;.&#39; to avoid the error of using &#39;.&#39; in the key of `ModuleDict`.</span>
</span><span id="CLBackbone.__init__-36"><a href="#CLBackbone.__init__-36"><span class="linenos">36</span></a><span class="sd">        </span>
</span><span id="CLBackbone.__init__-37"><a href="#CLBackbone.__init__-37"><span class="linenos">37</span></a><span class="sd">        In HAT architecture, it&#39;s also the layer names with task embedding masking in the order of forward pass. HAT gives task embedding to every possible weighted layer. </span>
</span><span id="CLBackbone.__init__-38"><a href="#CLBackbone.__init__-38"><span class="linenos">38</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="CLBackbone.__init__-39"><a href="#CLBackbone.__init__-39"><span class="linenos">39</span></a>
</span><span id="CLBackbone.__init__-40"><a href="#CLBackbone.__init__-40"><span class="linenos">40</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">task_id</span><span class="p">:</span> <span class="nb">int</span>
</span><span id="CLBackbone.__init__-41"><a href="#CLBackbone.__init__-41"><span class="linenos">41</span></a><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Task ID counter indicating which task is being processed. Self updated during the task loop.&quot;&quot;&quot;</span>
</span></pre></div>


            <div class="docstring"><p>Initialise the CL backbone network.</p>

<p><strong>Args:</strong></p>

<ul>
<li><strong>output_dim</strong> (<code>int</code> | <code>None</code>): The output dimension which connects to CL output heads. The <code>input_dim</code> of output heads are expected to be the same as this <code><a href="#CLBackbone.output_dim">output_dim</a></code>. In some cases, this class is used for a block in the backbone network, which doesn't have the output dimension. In this case, it can be <code>None</code>.</li>
</ul>
</div>


                            </div>
                            <div id="CLBackbone.output_dim" class="classattr">
                                <div class="attr variable">
            <span class="name">output_dim</span><span class="annotation">: int</span>

        
    </div>
    <a class="headerlink" href="#CLBackbone.output_dim"></a>
    
            <div class="docstring"><p>Store the output dimension of the backbone network.</p>
</div>


                            </div>
                            <div id="CLBackbone.weighted_layer_names" class="classattr">
                                <div class="attr variable">
            <span class="name">weighted_layer_names</span><span class="annotation">: list[str]</span>

        
    </div>
    <a class="headerlink" href="#CLBackbone.weighted_layer_names"></a>
    
            <div class="docstring"><p>Maintain a list of the weighted layer names. Weighted layer has weights connecting to other weighted layer. They are the main part of neural networks. <strong>It must be provided in subclasses.</strong></p>

<p>The names are following the <code>nn.Module</code> internal naming mechanism. For example, if the a layer is assigned to <code>self.conv1</code>, the name becomes <code>conv1</code>. If the <code>nn.Sequential</code> is used, the name becomes the index of the layer in the sequence, such as <code>0</code>, <code>1</code>, etc. If hierarchical structure is used, for example, a <code>nn.Module</code> is assigned to <code>self.block</code> which has <code>self.conv1</code>, the name becomes <code>block/conv1</code>. Note that it should be <code>block.conv1</code> according to <code>nn.Module</code> internal mechanism, but we use '/' instead of '.' to avoid the error of using '.' in the key of <code>ModuleDict</code>.</p>

<p>In HAT architecture, it's also the layer names with task embedding masking in the order of forward pass. HAT gives task embedding to every possible weighted layer.</p>
</div>


                            </div>
                            <div id="CLBackbone.task_id" class="classattr">
                                <div class="attr variable">
            <span class="name">task_id</span><span class="annotation">: int</span>

        
    </div>
    <a class="headerlink" href="#CLBackbone.task_id"></a>
    
            <div class="docstring"><p>Task ID counter indicating which task is being processed. Self updated during the task loop.</p>
</div>


                            </div>
                            <div id="CLBackbone.setup_task_id" class="classattr">
                                        <input id="CLBackbone.setup_task_id-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">setup_task_id</span><span class="signature pdoc-code condensed">(<span class="param"><span class="bp">self</span>, </span><span class="param"><span class="n">task_id</span><span class="p">:</span> <span class="nb">int</span></span><span class="return-annotation">) -> <span class="kc">None</span>:</span></span>

                <label class="view-source-button" for="CLBackbone.setup_task_id-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#CLBackbone.setup_task_id"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="CLBackbone.setup_task_id-43"><a href="#CLBackbone.setup_task_id-43"><span class="linenos">43</span></a>    <span class="k">def</span><span class="w"> </span><span class="nf">setup_task_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="CLBackbone.setup_task_id-44"><a href="#CLBackbone.setup_task_id-44"><span class="linenos">44</span></a><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Set up which task&#39;s dataset the CL experiment is on. This must be done before `forward()` method is called.</span>
</span><span id="CLBackbone.setup_task_id-45"><a href="#CLBackbone.setup_task_id-45"><span class="linenos">45</span></a>
</span><span id="CLBackbone.setup_task_id-46"><a href="#CLBackbone.setup_task_id-46"><span class="linenos">46</span></a><span class="sd">        **Args:**</span>
</span><span id="CLBackbone.setup_task_id-47"><a href="#CLBackbone.setup_task_id-47"><span class="linenos">47</span></a><span class="sd">        - **task_id** (`int`): the target task ID.</span>
</span><span id="CLBackbone.setup_task_id-48"><a href="#CLBackbone.setup_task_id-48"><span class="linenos">48</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="CLBackbone.setup_task_id-49"><a href="#CLBackbone.setup_task_id-49"><span class="linenos">49</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">task_id</span> <span class="o">=</span> <span class="n">task_id</span>
</span></pre></div>


            <div class="docstring"><p>Set up which task's dataset the CL experiment is on. This must be done before <code><a href="#CLBackbone.forward">forward()</a></code> method is called.</p>

<p><strong>Args:</strong></p>

<ul>
<li><strong>task_id</strong> (<code>int</code>): the target task ID.</li>
</ul>
</div>


                            </div>
                            <div id="CLBackbone.get_layer_by_name" class="classattr">
                                        <input id="CLBackbone.get_layer_by_name-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">get_layer_by_name</span><span class="signature pdoc-code condensed">(<span class="param"><span class="bp">self</span>, </span><span class="param"><span class="n">layer_name</span><span class="p">:</span> <span class="nb">str</span></span><span class="return-annotation">) -> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">module</span><span class="o">.</span><span class="n">Module</span>:</span></span>

                <label class="view-source-button" for="CLBackbone.get_layer_by_name-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#CLBackbone.get_layer_by_name"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="CLBackbone.get_layer_by_name-51"><a href="#CLBackbone.get_layer_by_name-51"><span class="linenos">51</span></a>    <span class="k">def</span><span class="w"> </span><span class="nf">get_layer_by_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">:</span>
</span><span id="CLBackbone.get_layer_by_name-52"><a href="#CLBackbone.get_layer_by_name-52"><span class="linenos">52</span></a><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Get the layer by its name.</span>
</span><span id="CLBackbone.get_layer_by_name-53"><a href="#CLBackbone.get_layer_by_name-53"><span class="linenos">53</span></a>
</span><span id="CLBackbone.get_layer_by_name-54"><a href="#CLBackbone.get_layer_by_name-54"><span class="linenos">54</span></a><span class="sd">        **Args:**</span>
</span><span id="CLBackbone.get_layer_by_name-55"><a href="#CLBackbone.get_layer_by_name-55"><span class="linenos">55</span></a><span class="sd">        - **layer_name** (`str`): the name of the layer. Note that the name is the name substituting the &#39;.&#39; with &#39;/&#39;, like `block/conv1`, rather than `block.conv1`.</span>
</span><span id="CLBackbone.get_layer_by_name-56"><a href="#CLBackbone.get_layer_by_name-56"><span class="linenos">56</span></a>
</span><span id="CLBackbone.get_layer_by_name-57"><a href="#CLBackbone.get_layer_by_name-57"><span class="linenos">57</span></a><span class="sd">        **Returns:**</span>
</span><span id="CLBackbone.get_layer_by_name-58"><a href="#CLBackbone.get_layer_by_name-58"><span class="linenos">58</span></a><span class="sd">        - **layer** (`nn.Module`): the layer.</span>
</span><span id="CLBackbone.get_layer_by_name-59"><a href="#CLBackbone.get_layer_by_name-59"><span class="linenos">59</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="CLBackbone.get_layer_by_name-60"><a href="#CLBackbone.get_layer_by_name-60"><span class="linenos">60</span></a>        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">layer</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">named_modules</span><span class="p">():</span>
</span><span id="CLBackbone.get_layer_by_name-61"><a href="#CLBackbone.get_layer_by_name-61"><span class="linenos">61</span></a>            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="n">layer_name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="s2">&quot;.&quot;</span><span class="p">):</span>
</span><span id="CLBackbone.get_layer_by_name-62"><a href="#CLBackbone.get_layer_by_name-62"><span class="linenos">62</span></a>                <span class="k">return</span> <span class="n">layer</span>
</span></pre></div>


            <div class="docstring"><p>Get the layer by its name.</p>

<p><strong>Args:</strong></p>

<ul>
<li><strong>layer_name</strong> (<code>str</code>): the name of the layer. Note that the name is the name substituting the '.' with '/', like <code>block/conv1</code>, rather than <code>block.conv1</code>.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li><strong>layer</strong> (<code>nn.Module</code>): the layer.</li>
</ul>
</div>


                            </div>
                            <div id="CLBackbone.preceding_layer_name" class="classattr">
                                        <input id="CLBackbone.preceding_layer_name-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">preceding_layer_name</span><span class="signature pdoc-code condensed">(<span class="param"><span class="bp">self</span>, </span><span class="param"><span class="n">layer_name</span><span class="p">:</span> <span class="nb">str</span></span><span class="return-annotation">) -> <span class="nb">str</span>:</span></span>

                <label class="view-source-button" for="CLBackbone.preceding_layer_name-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#CLBackbone.preceding_layer_name"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="CLBackbone.preceding_layer_name-64"><a href="#CLBackbone.preceding_layer_name-64"><span class="linenos">64</span></a>    <span class="k">def</span><span class="w"> </span><span class="nf">preceding_layer_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
</span><span id="CLBackbone.preceding_layer_name-65"><a href="#CLBackbone.preceding_layer_name-65"><span class="linenos">65</span></a><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Get the name of the preceding layer of the given layer from the stored `self.masked_layer_order`. If the given layer is the first layer, return `None`.</span>
</span><span id="CLBackbone.preceding_layer_name-66"><a href="#CLBackbone.preceding_layer_name-66"><span class="linenos">66</span></a>
</span><span id="CLBackbone.preceding_layer_name-67"><a href="#CLBackbone.preceding_layer_name-67"><span class="linenos">67</span></a><span class="sd">        **Args:**</span>
</span><span id="CLBackbone.preceding_layer_name-68"><a href="#CLBackbone.preceding_layer_name-68"><span class="linenos">68</span></a><span class="sd">        - **layer_name** (`str`): the name of the layer.</span>
</span><span id="CLBackbone.preceding_layer_name-69"><a href="#CLBackbone.preceding_layer_name-69"><span class="linenos">69</span></a>
</span><span id="CLBackbone.preceding_layer_name-70"><a href="#CLBackbone.preceding_layer_name-70"><span class="linenos">70</span></a><span class="sd">        **Returns:**</span>
</span><span id="CLBackbone.preceding_layer_name-71"><a href="#CLBackbone.preceding_layer_name-71"><span class="linenos">71</span></a><span class="sd">        - **preceding_layer_name** (`str`): the name of the preceding layer.</span>
</span><span id="CLBackbone.preceding_layer_name-72"><a href="#CLBackbone.preceding_layer_name-72"><span class="linenos">72</span></a>
</span><span id="CLBackbone.preceding_layer_name-73"><a href="#CLBackbone.preceding_layer_name-73"><span class="linenos">73</span></a><span class="sd">        **Raises:**</span>
</span><span id="CLBackbone.preceding_layer_name-74"><a href="#CLBackbone.preceding_layer_name-74"><span class="linenos">74</span></a><span class="sd">        - **ValueError**: if `layer_name` is not in the weighted layer order.</span>
</span><span id="CLBackbone.preceding_layer_name-75"><a href="#CLBackbone.preceding_layer_name-75"><span class="linenos">75</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="CLBackbone.preceding_layer_name-76"><a href="#CLBackbone.preceding_layer_name-76"><span class="linenos">76</span></a>
</span><span id="CLBackbone.preceding_layer_name-77"><a href="#CLBackbone.preceding_layer_name-77"><span class="linenos">77</span></a>        <span class="k">if</span> <span class="n">layer_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted_layer_names</span><span class="p">:</span>
</span><span id="CLBackbone.preceding_layer_name-78"><a href="#CLBackbone.preceding_layer_name-78"><span class="linenos">78</span></a>            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The layer name </span><span class="si">{</span><span class="n">layer_name</span><span class="si">}</span><span class="s2"> doesn&#39;t exist.&quot;</span><span class="p">)</span>
</span><span id="CLBackbone.preceding_layer_name-79"><a href="#CLBackbone.preceding_layer_name-79"><span class="linenos">79</span></a>
</span><span id="CLBackbone.preceding_layer_name-80"><a href="#CLBackbone.preceding_layer_name-80"><span class="linenos">80</span></a>        <span class="n">weighted_layer_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted_layer_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">layer_name</span><span class="p">)</span>
</span><span id="CLBackbone.preceding_layer_name-81"><a href="#CLBackbone.preceding_layer_name-81"><span class="linenos">81</span></a>        <span class="k">if</span> <span class="n">weighted_layer_idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span><span id="CLBackbone.preceding_layer_name-82"><a href="#CLBackbone.preceding_layer_name-82"><span class="linenos">82</span></a>            <span class="k">return</span> <span class="kc">None</span>
</span><span id="CLBackbone.preceding_layer_name-83"><a href="#CLBackbone.preceding_layer_name-83"><span class="linenos">83</span></a>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted_layer_names</span><span class="p">[</span><span class="n">weighted_layer_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
</span></pre></div>


            <div class="docstring"><p>Get the name of the preceding layer of the given layer from the stored <code>self.masked_layer_order</code>. If the given layer is the first layer, return <code>None</code>.</p>

<p><strong>Args:</strong></p>

<ul>
<li><strong>layer_name</strong> (<code>str</code>): the name of the layer.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li><strong>preceding_layer_name</strong> (<code>str</code>): the name of the preceding layer.</li>
</ul>

<p><strong>Raises:</strong></p>

<ul>
<li><strong>ValueError</strong>: if <code>layer_name</code> is not in the weighted layer order.</li>
</ul>
</div>


                            </div>
                            <div id="CLBackbone.forward" class="classattr">
                                        <input id="CLBackbone.forward-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
                    <div class="decorator decorator-override">@override</div>

        <span class="def">def</span>
        <span class="name">forward</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="bp">self</span>,</span><span class="param">	<span class="nb">input</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span>,</span><span class="param">	<span class="n">stage</span><span class="p">:</span> <span class="nb">str</span>,</span><span class="param">	<span class="n">task_id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span></span><span class="return-annotation">) -> <span class="nb">tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]</span>:</span></span>

                <label class="view-source-button" for="CLBackbone.forward-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#CLBackbone.forward"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="CLBackbone.forward-85"><a href="#CLBackbone.forward-85"><span class="linenos"> 85</span></a>    <span class="nd">@override</span>  <span class="c1"># since `nn.Module` uses it</span>
</span><span id="CLBackbone.forward-86"><a href="#CLBackbone.forward-86"><span class="linenos"> 86</span></a>    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span>
</span><span id="CLBackbone.forward-87"><a href="#CLBackbone.forward-87"><span class="linenos"> 87</span></a>        <span class="bp">self</span><span class="p">,</span>
</span><span id="CLBackbone.forward-88"><a href="#CLBackbone.forward-88"><span class="linenos"> 88</span></a>        <span class="nb">input</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
</span><span id="CLBackbone.forward-89"><a href="#CLBackbone.forward-89"><span class="linenos"> 89</span></a>        <span class="n">stage</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
</span><span id="CLBackbone.forward-90"><a href="#CLBackbone.forward-90"><span class="linenos"> 90</span></a>        <span class="n">task_id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
</span><span id="CLBackbone.forward-91"><a href="#CLBackbone.forward-91"><span class="linenos"> 91</span></a>    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]]:</span>
</span><span id="CLBackbone.forward-92"><a href="#CLBackbone.forward-92"><span class="linenos"> 92</span></a><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;The forward pass for data from task `task_id`. In some backbones, the forward pass might be different for different tasks. **It must be implemented by subclasses.**</span>
</span><span id="CLBackbone.forward-93"><a href="#CLBackbone.forward-93"><span class="linenos"> 93</span></a>
</span><span id="CLBackbone.forward-94"><a href="#CLBackbone.forward-94"><span class="linenos"> 94</span></a><span class="sd">        **Args:**</span>
</span><span id="CLBackbone.forward-95"><a href="#CLBackbone.forward-95"><span class="linenos"> 95</span></a><span class="sd">        - **input** (`Tensor`): The input tensor from data.</span>
</span><span id="CLBackbone.forward-96"><a href="#CLBackbone.forward-96"><span class="linenos"> 96</span></a><span class="sd">        - **stage** (`str`): the stage of the forward pass, should be one of the following:</span>
</span><span id="CLBackbone.forward-97"><a href="#CLBackbone.forward-97"><span class="linenos"> 97</span></a><span class="sd">            1. &#39;train&#39;: training stage.</span>
</span><span id="CLBackbone.forward-98"><a href="#CLBackbone.forward-98"><span class="linenos"> 98</span></a><span class="sd">            2. &#39;validation&#39;: validation stage.</span>
</span><span id="CLBackbone.forward-99"><a href="#CLBackbone.forward-99"><span class="linenos"> 99</span></a><span class="sd">            3. &#39;test&#39;: testing stage.</span>
</span><span id="CLBackbone.forward-100"><a href="#CLBackbone.forward-100"><span class="linenos">100</span></a><span class="sd">        - **task_id** (`int` | `None`): the task ID where the data are from. If stage is &#39;train&#39; or &#39;validation&#39;, it is usually from the current task `self.task_id`. If stage is &#39;test&#39;, it could be from any seen task. In TIL, the task IDs of test data are provided thus this argument can be used. In CIL, they are not provided, so it is just a placeholder for API consistence but never used, and best practices are not to provide this argument and leave it as the default value.</span>
</span><span id="CLBackbone.forward-101"><a href="#CLBackbone.forward-101"><span class="linenos">101</span></a>
</span><span id="CLBackbone.forward-102"><a href="#CLBackbone.forward-102"><span class="linenos">102</span></a><span class="sd">        **Returns:**</span>
</span><span id="CLBackbone.forward-103"><a href="#CLBackbone.forward-103"><span class="linenos">103</span></a><span class="sd">        - **output_feature** (`Tensor`): the output feature tensor to be passed into heads. This is the main target of backpropagation.</span>
</span><span id="CLBackbone.forward-104"><a href="#CLBackbone.forward-104"><span class="linenos">104</span></a><span class="sd">        - **activations** (`dict[str, Tensor]`): the hidden features (after activation) in each weighted layer. Key (`str`) is the weighted layer name, value (`Tensor`) is the hidden feature tensor. This is used for the continual learning algorithms that need to use the hidden features for various purposes.</span>
</span><span id="CLBackbone.forward-105"><a href="#CLBackbone.forward-105"><span class="linenos">105</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span></pre></div>


            <div class="docstring"><p>The forward pass for data from task <code><a href="#CLBackbone.task_id">task_id</a></code>. In some backbones, the forward pass might be different for different tasks. <strong>It must be implemented by subclasses.</strong></p>

<p><strong>Args:</strong></p>

<ul>
<li><strong>input</strong> (<code>Tensor</code>): The input tensor from data.</li>
<li><strong>stage</strong> (<code>str</code>): the stage of the forward pass, should be one of the following:
<ol>
<li>'train': training stage.</li>
<li>'validation': validation stage.</li>
<li>'test': testing stage.</li>
</ol></li>
<li><strong>task_id</strong> (<code>int</code> | <code>None</code>): the task ID where the data are from. If stage is 'train' or 'validation', it is usually from the current task <code>self.task_id</code>. If stage is 'test', it could be from any seen task. In TIL, the task IDs of test data are provided thus this argument can be used. In CIL, they are not provided, so it is just a placeholder for API consistence but never used, and best practices are not to provide this argument and leave it as the default value.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li><strong>output_feature</strong> (<code>Tensor</code>): the output feature tensor to be passed into heads. This is the main target of backpropagation.</li>
<li><strong>activations</strong> (<code>dict[str, Tensor]</code>): the hidden features (after activation) in each weighted layer. Key (<code>str</code>) is the weighted layer name, value (<code>Tensor</code>) is the hidden feature tensor. This is used for the continual learning algorithms that need to use the hidden features for various purposes.</li>
</ul>
</div>


                            </div>
                </section>
                <section id="HATMaskBackbone">
                            <input id="HATMaskBackbone-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr class">
            
    <span class="def">class</span>
    <span class="name">HATMaskBackbone</span><wbr>(<span class="base"><a href="#CLBackbone">clarena.backbones.CLBackbone</a></span>):

                <label class="view-source-button" for="HATMaskBackbone-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#HATMaskBackbone"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="HATMaskBackbone-108"><a href="#HATMaskBackbone-108"><span class="linenos">108</span></a><span class="k">class</span><span class="w"> </span><span class="nc">HATMaskBackbone</span><span class="p">(</span><span class="n">CLBackbone</span><span class="p">):</span>
</span><span id="HATMaskBackbone-109"><a href="#HATMaskBackbone-109"><span class="linenos">109</span></a><span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;The backbone network for HAT-based algorithms with learnable hard attention masks.</span>
</span><span id="HATMaskBackbone-110"><a href="#HATMaskBackbone-110"><span class="linenos">110</span></a>
</span><span id="HATMaskBackbone-111"><a href="#HATMaskBackbone-111"><span class="linenos">111</span></a><span class="sd">    HAT-based algorithms:</span>
</span><span id="HATMaskBackbone-112"><a href="#HATMaskBackbone-112"><span class="linenos">112</span></a>
</span><span id="HATMaskBackbone-113"><a href="#HATMaskBackbone-113"><span class="linenos">113</span></a><span class="sd">    - [**HAT (Hard Attention to the Task, 2018)**](http://proceedings.mlr.press/v80/serra18a) is an architecture-based continual learning approach that uses learnable hard attention masks to select the task-specific parameters.</span>
</span><span id="HATMaskBackbone-114"><a href="#HATMaskBackbone-114"><span class="linenos">114</span></a><span class="sd">    - [**Adaptive HAT (Adaptive Hard Attention to the Task, 2024)**](https://link.springer.com/chapter/10.1007/978-3-031-70352-2_9) is an architecture-based continual learning approach that improves [HAT (Hard Attention to the Task, 2018)](http://proceedings.mlr.press/v80/serra18a) by introducing new adaptive soft gradient clipping based on parameter importance and network sparsity.</span>
</span><span id="HATMaskBackbone-115"><a href="#HATMaskBackbone-115"><span class="linenos">115</span></a><span class="sd">    - **CBPHAT** is what I am working on, trying combining HAT (Hard Attention to the Task) algorithm with Continual Backpropagation (CBP) by leveraging the contribution utility as the parameter importance like in AdaHAT (Adaptive Hard Attention to the Task) algorithm.</span>
</span><span id="HATMaskBackbone-116"><a href="#HATMaskBackbone-116"><span class="linenos">116</span></a><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="HATMaskBackbone-117"><a href="#HATMaskBackbone-117"><span class="linenos">117</span></a>
</span><span id="HATMaskBackbone-118"><a href="#HATMaskBackbone-118"><span class="linenos">118</span></a>    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_dim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">gate</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="HATMaskBackbone-119"><a href="#HATMaskBackbone-119"><span class="linenos">119</span></a><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Initialise the HAT mask backbone network with task embeddings and masks.</span>
</span><span id="HATMaskBackbone-120"><a href="#HATMaskBackbone-120"><span class="linenos">120</span></a>
</span><span id="HATMaskBackbone-121"><a href="#HATMaskBackbone-121"><span class="linenos">121</span></a><span class="sd">        **Args:**</span>
</span><span id="HATMaskBackbone-122"><a href="#HATMaskBackbone-122"><span class="linenos">122</span></a><span class="sd">        - **output_dim** (`int`): The output dimension which connects to CL output heads. The `input_dim` of output heads are expected to be the same as this `output_dim`. In some cases, this class is used for a block in the backbone network, which doesn&#39;t have the output dimension. In this case, it can be `None`.</span>
</span><span id="HATMaskBackbone-123"><a href="#HATMaskBackbone-123"><span class="linenos">123</span></a><span class="sd">        - **gate** (`str`): the type of gate function turning the real value task embeddings into attention masks, should be one of the following:</span>
</span><span id="HATMaskBackbone-124"><a href="#HATMaskBackbone-124"><span class="linenos">124</span></a><span class="sd">            - `sigmoid`: the sigmoid function.</span>
</span><span id="HATMaskBackbone-125"><a href="#HATMaskBackbone-125"><span class="linenos">125</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="HATMaskBackbone-126"><a href="#HATMaskBackbone-126"><span class="linenos">126</span></a>        <span class="n">CLBackbone</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_dim</span><span class="o">=</span><span class="n">output_dim</span><span class="p">)</span>
</span><span id="HATMaskBackbone-127"><a href="#HATMaskBackbone-127"><span class="linenos">127</span></a>
</span><span id="HATMaskBackbone-128"><a href="#HATMaskBackbone-128"><span class="linenos">128</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">register_hat_mask_module_explicitly</span><span class="p">(</span>
</span><span id="HATMaskBackbone-129"><a href="#HATMaskBackbone-129"><span class="linenos">129</span></a>            <span class="n">gate</span><span class="o">=</span><span class="n">gate</span>
</span><span id="HATMaskBackbone-130"><a href="#HATMaskBackbone-130"><span class="linenos">130</span></a>        <span class="p">)</span>  <span class="c1"># we moved the registration of the modules to a separate method to solve a problem of multiple inheritance in terms of `nn.Module`</span>
</span><span id="HATMaskBackbone-131"><a href="#HATMaskBackbone-131"><span class="linenos">131</span></a>
</span><span id="HATMaskBackbone-132"><a href="#HATMaskBackbone-132"><span class="linenos">132</span></a>        <span class="n">HATMaskBackbone</span><span class="o">.</span><span class="n">sanity_check</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</span><span id="HATMaskBackbone-133"><a href="#HATMaskBackbone-133"><span class="linenos">133</span></a>
</span><span id="HATMaskBackbone-134"><a href="#HATMaskBackbone-134"><span class="linenos">134</span></a>    <span class="k">def</span><span class="w"> </span><span class="nf">register_hat_mask_module_explicitly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gate</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="HATMaskBackbone-135"><a href="#HATMaskBackbone-135"><span class="linenos">135</span></a><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Register all `nn.Module`s explicitly in this method. For `HATMaskBackbone`, they are task embedding for the current task and the masks.</span>
</span><span id="HATMaskBackbone-136"><a href="#HATMaskBackbone-136"><span class="linenos">136</span></a>
</span><span id="HATMaskBackbone-137"><a href="#HATMaskBackbone-137"><span class="linenos">137</span></a><span class="sd">        **Args:**</span>
</span><span id="HATMaskBackbone-138"><a href="#HATMaskBackbone-138"><span class="linenos">138</span></a><span class="sd">        - **gate** (`str`): the type of gate function turning the real value task embeddings into attention masks, should be one of the following:</span>
</span><span id="HATMaskBackbone-139"><a href="#HATMaskBackbone-139"><span class="linenos">139</span></a><span class="sd">            - `sigmoid`: the sigmoid function.</span>
</span><span id="HATMaskBackbone-140"><a href="#HATMaskBackbone-140"><span class="linenos">140</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="HATMaskBackbone-141"><a href="#HATMaskBackbone-141"><span class="linenos">141</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">gate</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">gate</span>
</span><span id="HATMaskBackbone-142"><a href="#HATMaskBackbone-142"><span class="linenos">142</span></a><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Store the type of gate function.&quot;&quot;&quot;</span>
</span><span id="HATMaskBackbone-143"><a href="#HATMaskBackbone-143"><span class="linenos">143</span></a>        <span class="k">if</span> <span class="n">gate</span> <span class="o">==</span> <span class="s2">&quot;sigmoid&quot;</span><span class="p">:</span>
</span><span id="HATMaskBackbone-144"><a href="#HATMaskBackbone-144"><span class="linenos">144</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">gate_fn</span><span class="p">:</span> <span class="n">nn</span><span class="o">.</span><span class="n">Module</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sigmoid</span><span class="p">()</span>
</span><span id="HATMaskBackbone-145"><a href="#HATMaskBackbone-145"><span class="linenos">145</span></a><span class="w">            </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;The gate function turning the real value task embeddings into attention masks.&quot;&quot;&quot;</span>
</span><span id="HATMaskBackbone-146"><a href="#HATMaskBackbone-146"><span class="linenos">146</span></a>
</span><span id="HATMaskBackbone-147"><a href="#HATMaskBackbone-147"><span class="linenos">147</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">task_embedding_t</span><span class="p">:</span> <span class="n">nn</span><span class="o">.</span><span class="n">ModuleDict</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">ModuleDict</span><span class="p">()</span>
</span><span id="HATMaskBackbone-148"><a href="#HATMaskBackbone-148"><span class="linenos">148</span></a><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Store the task embedding for the current task. Keys are the layer names and values are the task embedding `nn.Embedding` for the layer. Each task embedding has size (1, number of units).</span>
</span><span id="HATMaskBackbone-149"><a href="#HATMaskBackbone-149"><span class="linenos">149</span></a><span class="sd">        </span>
</span><span id="HATMaskBackbone-150"><a href="#HATMaskBackbone-150"><span class="linenos">150</span></a><span class="sd">        We use `ModuleDict` rather than `dict` to make sure `LightningModule` can properly register these model parameters for the purpose of, like automatically transfering to device, being recorded in model summaries.</span>
</span><span id="HATMaskBackbone-151"><a href="#HATMaskBackbone-151"><span class="linenos">151</span></a><span class="sd">        </span>
</span><span id="HATMaskBackbone-152"><a href="#HATMaskBackbone-152"><span class="linenos">152</span></a><span class="sd">        we use `nn.Embedding` rather than `nn.Parameter` to store the task embedding for each layer, which is a type of `nn.Module` and can be accepted by `nn.ModuleDict`. (`nn.Parameter` cannot be accepted by `nn.ModuleDict`.)</span>
</span><span id="HATMaskBackbone-153"><a href="#HATMaskBackbone-153"><span class="linenos">153</span></a><span class="sd">        </span>
</span><span id="HATMaskBackbone-154"><a href="#HATMaskBackbone-154"><span class="linenos">154</span></a><span class="sd">        **This must be defined to cover each weighted layer (just as `self.weighted_layer_names` listed) in the backbone network.** Otherwise, the uncovered parts will keep updating for all tasks and become a source of catastrophic forgetting. &quot;&quot;&quot;</span>
</span><span id="HATMaskBackbone-155"><a href="#HATMaskBackbone-155"><span class="linenos">155</span></a>
</span><span id="HATMaskBackbone-156"><a href="#HATMaskBackbone-156"><span class="linenos">156</span></a>    <span class="k">def</span><span class="w"> </span><span class="nf">initialise_task_embedding</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="HATMaskBackbone-157"><a href="#HATMaskBackbone-157"><span class="linenos">157</span></a><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Initialise the task embedding for the current task.</span>
</span><span id="HATMaskBackbone-158"><a href="#HATMaskBackbone-158"><span class="linenos">158</span></a>
</span><span id="HATMaskBackbone-159"><a href="#HATMaskBackbone-159"><span class="linenos">159</span></a><span class="sd">        **Args:**</span>
</span><span id="HATMaskBackbone-160"><a href="#HATMaskBackbone-160"><span class="linenos">160</span></a><span class="sd">        - **mode** (`str`): the initialisation mode for task embeddings, should be one of the following:</span>
</span><span id="HATMaskBackbone-161"><a href="#HATMaskBackbone-161"><span class="linenos">161</span></a><span class="sd">            1. &#39;N01&#39; (default): standard normal distribution $N(0, 1)$.</span>
</span><span id="HATMaskBackbone-162"><a href="#HATMaskBackbone-162"><span class="linenos">162</span></a><span class="sd">            2. &#39;U-11&#39;: uniform distribution $U(-1, 1)$.</span>
</span><span id="HATMaskBackbone-163"><a href="#HATMaskBackbone-163"><span class="linenos">163</span></a><span class="sd">            3. &#39;U01&#39;: uniform distribution $U(0, 1)$.</span>
</span><span id="HATMaskBackbone-164"><a href="#HATMaskBackbone-164"><span class="linenos">164</span></a><span class="sd">            4. &#39;U-10&#39;: uniform distribution $U(-1, 0)$.</span>
</span><span id="HATMaskBackbone-165"><a href="#HATMaskBackbone-165"><span class="linenos">165</span></a><span class="sd">            5. &#39;last&#39;: inherit task embedding from last task.</span>
</span><span id="HATMaskBackbone-166"><a href="#HATMaskBackbone-166"><span class="linenos">166</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="HATMaskBackbone-167"><a href="#HATMaskBackbone-167"><span class="linenos">167</span></a>        <span class="k">for</span> <span class="n">te</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">task_embedding_t</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
</span><span id="HATMaskBackbone-168"><a href="#HATMaskBackbone-168"><span class="linenos">168</span></a>            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;N01&quot;</span><span class="p">:</span>
</span><span id="HATMaskBackbone-169"><a href="#HATMaskBackbone-169"><span class="linenos">169</span></a>                <span class="n">nn</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">normal_</span><span class="p">(</span><span class="n">te</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span><span id="HATMaskBackbone-170"><a href="#HATMaskBackbone-170"><span class="linenos">170</span></a>            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;U-11&quot;</span><span class="p">:</span>
</span><span id="HATMaskBackbone-171"><a href="#HATMaskBackbone-171"><span class="linenos">171</span></a>                <span class="n">nn</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">uniform_</span><span class="p">(</span><span class="n">te</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span><span id="HATMaskBackbone-172"><a href="#HATMaskBackbone-172"><span class="linenos">172</span></a>            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;U01&quot;</span><span class="p">:</span>
</span><span id="HATMaskBackbone-173"><a href="#HATMaskBackbone-173"><span class="linenos">173</span></a>                <span class="n">nn</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">uniform_</span><span class="p">(</span><span class="n">te</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span><span id="HATMaskBackbone-174"><a href="#HATMaskBackbone-174"><span class="linenos">174</span></a>            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;U-10&quot;</span><span class="p">:</span>
</span><span id="HATMaskBackbone-175"><a href="#HATMaskBackbone-175"><span class="linenos">175</span></a>                <span class="n">nn</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">uniform_</span><span class="p">(</span><span class="n">te</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span><span id="HATMaskBackbone-176"><a href="#HATMaskBackbone-176"><span class="linenos">176</span></a>            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;last&quot;</span><span class="p">:</span>
</span><span id="HATMaskBackbone-177"><a href="#HATMaskBackbone-177"><span class="linenos">177</span></a>                <span class="k">pass</span>
</span><span id="HATMaskBackbone-178"><a href="#HATMaskBackbone-178"><span class="linenos">178</span></a>
</span><span id="HATMaskBackbone-179"><a href="#HATMaskBackbone-179"><span class="linenos">179</span></a>    <span class="k">def</span><span class="w"> </span><span class="nf">sanity_check</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="HATMaskBackbone-180"><a href="#HATMaskBackbone-180"><span class="linenos">180</span></a><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Check the sanity of the arguments.</span>
</span><span id="HATMaskBackbone-181"><a href="#HATMaskBackbone-181"><span class="linenos">181</span></a>
</span><span id="HATMaskBackbone-182"><a href="#HATMaskBackbone-182"><span class="linenos">182</span></a><span class="sd">        **Raises:**</span>
</span><span id="HATMaskBackbone-183"><a href="#HATMaskBackbone-183"><span class="linenos">183</span></a><span class="sd">        - **ValueError**: when the `gate` is not one of the valid options.</span>
</span><span id="HATMaskBackbone-184"><a href="#HATMaskBackbone-184"><span class="linenos">184</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="HATMaskBackbone-185"><a href="#HATMaskBackbone-185"><span class="linenos">185</span></a>
</span><span id="HATMaskBackbone-186"><a href="#HATMaskBackbone-186"><span class="linenos">186</span></a>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gate</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;sigmoid&quot;</span><span class="p">]:</span>
</span><span id="HATMaskBackbone-187"><a href="#HATMaskBackbone-187"><span class="linenos">187</span></a>            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The gate should be one of &#39;sigmoid&#39;.&quot;</span><span class="p">)</span>
</span><span id="HATMaskBackbone-188"><a href="#HATMaskBackbone-188"><span class="linenos">188</span></a>
</span><span id="HATMaskBackbone-189"><a href="#HATMaskBackbone-189"><span class="linenos">189</span></a>    <span class="k">def</span><span class="w"> </span><span class="nf">get_mask</span><span class="p">(</span>
</span><span id="HATMaskBackbone-190"><a href="#HATMaskBackbone-190"><span class="linenos">190</span></a>        <span class="bp">self</span><span class="p">,</span>
</span><span id="HATMaskBackbone-191"><a href="#HATMaskBackbone-191"><span class="linenos">191</span></a>        <span class="n">stage</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
</span><span id="HATMaskBackbone-192"><a href="#HATMaskBackbone-192"><span class="linenos">192</span></a>        <span class="n">s_max</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
</span><span id="HATMaskBackbone-193"><a href="#HATMaskBackbone-193"><span class="linenos">193</span></a>        <span class="n">batch_idx</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
</span><span id="HATMaskBackbone-194"><a href="#HATMaskBackbone-194"><span class="linenos">194</span></a>        <span class="n">num_batches</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
</span><span id="HATMaskBackbone-195"><a href="#HATMaskBackbone-195"><span class="linenos">195</span></a>        <span class="n">test_mask</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
</span><span id="HATMaskBackbone-196"><a href="#HATMaskBackbone-196"><span class="linenos">196</span></a>    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]:</span>
</span><span id="HATMaskBackbone-197"><a href="#HATMaskBackbone-197"><span class="linenos">197</span></a><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Get the hard attention mask used in `forward()` method for different stages.</span>
</span><span id="HATMaskBackbone-198"><a href="#HATMaskBackbone-198"><span class="linenos">198</span></a>
</span><span id="HATMaskBackbone-199"><a href="#HATMaskBackbone-199"><span class="linenos">199</span></a><span class="sd">        **Args:**</span>
</span><span id="HATMaskBackbone-200"><a href="#HATMaskBackbone-200"><span class="linenos">200</span></a><span class="sd">        - **stage** (`str`): the stage when applying the conversion, should be one of the following:</span>
</span><span id="HATMaskBackbone-201"><a href="#HATMaskBackbone-201"><span class="linenos">201</span></a><span class="sd">            1. &#39;train&#39;: training stage. If stage is &#39;train&#39;, get the mask from task embedding of current task through the gate function, which is scaled by an annealed scalar. See chapter 2.4 &quot;Hard Attention Training&quot; in [HAT paper](http://proceedings.mlr.press/v80/serra18a).</span>
</span><span id="HATMaskBackbone-202"><a href="#HATMaskBackbone-202"><span class="linenos">202</span></a><span class="sd">            2. ‘validation&#39;: validation stage. If stage is &#39;validation&#39;, get the mask from task embedding of current task through the gate function, which is scaled by `s_max`. (Note that in this stage, the binary mask hasn&#39;t been stored yet as the training is not over.)</span>
</span><span id="HATMaskBackbone-203"><a href="#HATMaskBackbone-203"><span class="linenos">203</span></a><span class="sd">            3. &#39;test&#39;: testing stage. If stage is &#39;test&#39;, apply the mask gate function is scaled by `s_max`, the large scaling making masks nearly binary.</span>
</span><span id="HATMaskBackbone-204"><a href="#HATMaskBackbone-204"><span class="linenos">204</span></a><span class="sd">        - **s_max** (`float`): the maximum scaling factor in the gate function. Doesn&#39;t apply to testing stage. See chapter 2.4 &quot;Hard Attention Training&quot; in [HAT paper](http://proceedings.mlr.press/v80/serra18a).</span>
</span><span id="HATMaskBackbone-205"><a href="#HATMaskBackbone-205"><span class="linenos">205</span></a><span class="sd">        - **batch_idx** (`int` | `None`): the current batch index. Applies only to training stage. For other stages, it is default `None`.</span>
</span><span id="HATMaskBackbone-206"><a href="#HATMaskBackbone-206"><span class="linenos">206</span></a><span class="sd">        - **num_batches** (`int` | `None`): the total number of batches. Applies only to training stage. For other stages, it is default `None`.</span>
</span><span id="HATMaskBackbone-207"><a href="#HATMaskBackbone-207"><span class="linenos">207</span></a><span class="sd">        - **test_mask** (`dict[str, Tensor]` | `None`): the binary mask used for test. Applies only to testing stage. For other stages, it is default `None`.</span>
</span><span id="HATMaskBackbone-208"><a href="#HATMaskBackbone-208"><span class="linenos">208</span></a>
</span><span id="HATMaskBackbone-209"><a href="#HATMaskBackbone-209"><span class="linenos">209</span></a><span class="sd">        **Returns:**</span>
</span><span id="HATMaskBackbone-210"><a href="#HATMaskBackbone-210"><span class="linenos">210</span></a><span class="sd">        - **mask** (`dict[str, Tensor]`): the hard attention (whose values are 0 or 1) mask. Key (`str`) is layer name, value (`Tensor`) is the mask tensor. The mask tensor has size (number of units).</span>
</span><span id="HATMaskBackbone-211"><a href="#HATMaskBackbone-211"><span class="linenos">211</span></a>
</span><span id="HATMaskBackbone-212"><a href="#HATMaskBackbone-212"><span class="linenos">212</span></a><span class="sd">        **Raises:**</span>
</span><span id="HATMaskBackbone-213"><a href="#HATMaskBackbone-213"><span class="linenos">213</span></a><span class="sd">        - **ValueError**: if the `batch_idx` and `batch_num` are not provided in &#39;train&#39; stage; if the `s_max` is not provided in &#39;validation&#39; stage; if the `task_id` is not provided in &#39;test&#39; stage.</span>
</span><span id="HATMaskBackbone-214"><a href="#HATMaskBackbone-214"><span class="linenos">214</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="HATMaskBackbone-215"><a href="#HATMaskBackbone-215"><span class="linenos">215</span></a>
</span><span id="HATMaskBackbone-216"><a href="#HATMaskBackbone-216"><span class="linenos">216</span></a>        <span class="c1"># sanity check</span>
</span><span id="HATMaskBackbone-217"><a href="#HATMaskBackbone-217"><span class="linenos">217</span></a>        <span class="k">if</span> <span class="n">stage</span> <span class="o">==</span> <span class="s2">&quot;train&quot;</span> <span class="ow">and</span> <span class="p">(</span>
</span><span id="HATMaskBackbone-218"><a href="#HATMaskBackbone-218"><span class="linenos">218</span></a>            <span class="n">s_max</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">batch_idx</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">num_batches</span> <span class="ow">is</span> <span class="kc">None</span>
</span><span id="HATMaskBackbone-219"><a href="#HATMaskBackbone-219"><span class="linenos">219</span></a>        <span class="p">):</span>
</span><span id="HATMaskBackbone-220"><a href="#HATMaskBackbone-220"><span class="linenos">220</span></a>            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
</span><span id="HATMaskBackbone-221"><a href="#HATMaskBackbone-221"><span class="linenos">221</span></a>                <span class="s2">&quot;The `s_max`, `batch_idx` and `batch_num` should be provided at training stage, instead of the default value `None`.&quot;</span>
</span><span id="HATMaskBackbone-222"><a href="#HATMaskBackbone-222"><span class="linenos">222</span></a>            <span class="p">)</span>
</span><span id="HATMaskBackbone-223"><a href="#HATMaskBackbone-223"><span class="linenos">223</span></a>        <span class="k">if</span> <span class="n">stage</span> <span class="o">==</span> <span class="s2">&quot;validation&quot;</span> <span class="ow">and</span> <span class="p">(</span><span class="n">s_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
</span><span id="HATMaskBackbone-224"><a href="#HATMaskBackbone-224"><span class="linenos">224</span></a>            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
</span><span id="HATMaskBackbone-225"><a href="#HATMaskBackbone-225"><span class="linenos">225</span></a>                <span class="s2">&quot;The `s_max` should be provided at validation stage, instead of the default value `None`.&quot;</span>
</span><span id="HATMaskBackbone-226"><a href="#HATMaskBackbone-226"><span class="linenos">226</span></a>            <span class="p">)</span>
</span><span id="HATMaskBackbone-227"><a href="#HATMaskBackbone-227"><span class="linenos">227</span></a>        <span class="k">if</span> <span class="n">stage</span> <span class="o">==</span> <span class="s2">&quot;test&quot;</span> <span class="ow">and</span> <span class="p">(</span><span class="n">test_mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
</span><span id="HATMaskBackbone-228"><a href="#HATMaskBackbone-228"><span class="linenos">228</span></a>            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
</span><span id="HATMaskBackbone-229"><a href="#HATMaskBackbone-229"><span class="linenos">229</span></a>                <span class="s2">&quot;The `task_mask` should be provided at testing stage, instead of the default value `None`.&quot;</span>
</span><span id="HATMaskBackbone-230"><a href="#HATMaskBackbone-230"><span class="linenos">230</span></a>            <span class="p">)</span>
</span><span id="HATMaskBackbone-231"><a href="#HATMaskBackbone-231"><span class="linenos">231</span></a>
</span><span id="HATMaskBackbone-232"><a href="#HATMaskBackbone-232"><span class="linenos">232</span></a>        <span class="n">mask</span> <span class="o">=</span> <span class="p">{}</span>
</span><span id="HATMaskBackbone-233"><a href="#HATMaskBackbone-233"><span class="linenos">233</span></a>        <span class="k">if</span> <span class="n">stage</span> <span class="o">==</span> <span class="s2">&quot;train&quot;</span><span class="p">:</span>
</span><span id="HATMaskBackbone-234"><a href="#HATMaskBackbone-234"><span class="linenos">234</span></a>            <span class="k">for</span> <span class="n">layer_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted_layer_names</span><span class="p">:</span>
</span><span id="HATMaskBackbone-235"><a href="#HATMaskBackbone-235"><span class="linenos">235</span></a>                <span class="n">anneal_scalar</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">s_max</span> <span class="o">+</span> <span class="p">(</span><span class="n">s_max</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">s_max</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">batch_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span>
</span><span id="HATMaskBackbone-236"><a href="#HATMaskBackbone-236"><span class="linenos">236</span></a>                    <span class="n">num_batches</span> <span class="o">-</span> <span class="mi">1</span>
</span><span id="HATMaskBackbone-237"><a href="#HATMaskBackbone-237"><span class="linenos">237</span></a>                <span class="p">)</span>  <span class="c1"># see equation (3) in chapter 2.4 &quot;Hard Attention Training&quot; in [HAT paper](http://proceedings.mlr.press/v80/serra18a).</span>
</span><span id="HATMaskBackbone-238"><a href="#HATMaskBackbone-238"><span class="linenos">238</span></a>                <span class="n">mask</span><span class="p">[</span><span class="n">layer_name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gate_fn</span><span class="p">(</span>
</span><span id="HATMaskBackbone-239"><a href="#HATMaskBackbone-239"><span class="linenos">239</span></a>                    <span class="bp">self</span><span class="o">.</span><span class="n">task_embedding_t</span><span class="p">[</span><span class="n">layer_name</span><span class="p">]</span><span class="o">.</span><span class="n">weight</span> <span class="o">*</span> <span class="n">anneal_scalar</span>
</span><span id="HATMaskBackbone-240"><a href="#HATMaskBackbone-240"><span class="linenos">240</span></a>                <span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
</span><span id="HATMaskBackbone-241"><a href="#HATMaskBackbone-241"><span class="linenos">241</span></a>        <span class="k">elif</span> <span class="n">stage</span> <span class="o">==</span> <span class="s2">&quot;validation&quot;</span><span class="p">:</span>
</span><span id="HATMaskBackbone-242"><a href="#HATMaskBackbone-242"><span class="linenos">242</span></a>            <span class="k">for</span> <span class="n">layer_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted_layer_names</span><span class="p">:</span>
</span><span id="HATMaskBackbone-243"><a href="#HATMaskBackbone-243"><span class="linenos">243</span></a>                <span class="n">mask</span><span class="p">[</span><span class="n">layer_name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gate_fn</span><span class="p">(</span>
</span><span id="HATMaskBackbone-244"><a href="#HATMaskBackbone-244"><span class="linenos">244</span></a>                    <span class="bp">self</span><span class="o">.</span><span class="n">task_embedding_t</span><span class="p">[</span><span class="n">layer_name</span><span class="p">]</span><span class="o">.</span><span class="n">weight</span> <span class="o">*</span> <span class="n">s_max</span>
</span><span id="HATMaskBackbone-245"><a href="#HATMaskBackbone-245"><span class="linenos">245</span></a>                <span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
</span><span id="HATMaskBackbone-246"><a href="#HATMaskBackbone-246"><span class="linenos">246</span></a>        <span class="k">elif</span> <span class="n">stage</span> <span class="o">==</span> <span class="s2">&quot;test&quot;</span><span class="p">:</span>
</span><span id="HATMaskBackbone-247"><a href="#HATMaskBackbone-247"><span class="linenos">247</span></a>            <span class="n">mask</span> <span class="o">=</span> <span class="n">test_mask</span>
</span><span id="HATMaskBackbone-248"><a href="#HATMaskBackbone-248"><span class="linenos">248</span></a>
</span><span id="HATMaskBackbone-249"><a href="#HATMaskBackbone-249"><span class="linenos">249</span></a>        <span class="k">return</span> <span class="n">mask</span>
</span><span id="HATMaskBackbone-250"><a href="#HATMaskBackbone-250"><span class="linenos">250</span></a>
</span><span id="HATMaskBackbone-251"><a href="#HATMaskBackbone-251"><span class="linenos">251</span></a>    <span class="k">def</span><span class="w"> </span><span class="nf">get_cumulative_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]:</span>
</span><span id="HATMaskBackbone-252"><a href="#HATMaskBackbone-252"><span class="linenos">252</span></a><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Get the cumulative mask till current task.</span>
</span><span id="HATMaskBackbone-253"><a href="#HATMaskBackbone-253"><span class="linenos">253</span></a>
</span><span id="HATMaskBackbone-254"><a href="#HATMaskBackbone-254"><span class="linenos">254</span></a><span class="sd">        **Returns:**</span>
</span><span id="HATMaskBackbone-255"><a href="#HATMaskBackbone-255"><span class="linenos">255</span></a><span class="sd">        - **cumulative_mask** (`dict[str, Tensor]`): the cumulative mask. Key (`str`) is layer name, value (`Tensor`) is the mask tensor. The mask tensor has size (number of units).</span>
</span><span id="HATMaskBackbone-256"><a href="#HATMaskBackbone-256"><span class="linenos">256</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="HATMaskBackbone-257"><a href="#HATMaskBackbone-257"><span class="linenos">257</span></a>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cumulative_mask_for_previous_tasks</span>
</span><span id="HATMaskBackbone-258"><a href="#HATMaskBackbone-258"><span class="linenos">258</span></a>
</span><span id="HATMaskBackbone-259"><a href="#HATMaskBackbone-259"><span class="linenos">259</span></a>    <span class="k">def</span><span class="w"> </span><span class="nf">get_summative_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]:</span>
</span><span id="HATMaskBackbone-260"><a href="#HATMaskBackbone-260"><span class="linenos">260</span></a><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Get the summative mask till current task.</span>
</span><span id="HATMaskBackbone-261"><a href="#HATMaskBackbone-261"><span class="linenos">261</span></a>
</span><span id="HATMaskBackbone-262"><a href="#HATMaskBackbone-262"><span class="linenos">262</span></a><span class="sd">        **Returns:**</span>
</span><span id="HATMaskBackbone-263"><a href="#HATMaskBackbone-263"><span class="linenos">263</span></a><span class="sd">        - **summative_mask** (`dict[str, Tensor]`): the summative mask tensor. Key (`str`) is layer name, value (`Tensor`) is the mask tensor. The mask tensor has size (number of units).</span>
</span><span id="HATMaskBackbone-264"><a href="#HATMaskBackbone-264"><span class="linenos">264</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="HATMaskBackbone-265"><a href="#HATMaskBackbone-265"><span class="linenos">265</span></a>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">summative_mask_for_previous_tasks</span>
</span><span id="HATMaskBackbone-266"><a href="#HATMaskBackbone-266"><span class="linenos">266</span></a>
</span><span id="HATMaskBackbone-267"><a href="#HATMaskBackbone-267"><span class="linenos">267</span></a>    <span class="k">def</span><span class="w"> </span><span class="nf">get_layer_measure_parameter_wise</span><span class="p">(</span>
</span><span id="HATMaskBackbone-268"><a href="#HATMaskBackbone-268"><span class="linenos">268</span></a>        <span class="bp">self</span><span class="p">,</span>
</span><span id="HATMaskBackbone-269"><a href="#HATMaskBackbone-269"><span class="linenos">269</span></a>        <span class="n">unit_wise_measure</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">],</span>
</span><span id="HATMaskBackbone-270"><a href="#HATMaskBackbone-270"><span class="linenos">270</span></a>        <span class="n">layer_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
</span><span id="HATMaskBackbone-271"><a href="#HATMaskBackbone-271"><span class="linenos">271</span></a>        <span class="n">aggregation</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
</span><span id="HATMaskBackbone-272"><a href="#HATMaskBackbone-272"><span class="linenos">272</span></a>    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
</span><span id="HATMaskBackbone-273"><a href="#HATMaskBackbone-273"><span class="linenos">273</span></a><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Get the parameter-wise measure on the parameters right before the given layer.</span>
</span><span id="HATMaskBackbone-274"><a href="#HATMaskBackbone-274"><span class="linenos">274</span></a>
</span><span id="HATMaskBackbone-275"><a href="#HATMaskBackbone-275"><span class="linenos">275</span></a><span class="sd">        It is calculated from the given unit-wise measure. It aggregates two feature-sized vectors (corresponding the given layer and preceding layer) into a weight-wise matrix (corresponding the weights in between) and bias-wise vector (corresponding the bias of the given layer), using the given aggregation method. For example, given two feature-sized measure $m_{l,i}$ and $m_{l-1,j}$ and &#39;min&#39; aggregation, the parameter-wise measure is then $\min \left(a_{l,i}, a_{l-1,j}\right)$, a matrix with respect to $i, j$.</span>
</span><span id="HATMaskBackbone-276"><a href="#HATMaskBackbone-276"><span class="linenos">276</span></a>
</span><span id="HATMaskBackbone-277"><a href="#HATMaskBackbone-277"><span class="linenos">277</span></a><span class="sd">        Note that if the given layer is the first layer with no preceding layer, we will get parameter-wise measure directly broadcasted from the unit-wise measure of given layer.</span>
</span><span id="HATMaskBackbone-278"><a href="#HATMaskBackbone-278"><span class="linenos">278</span></a>
</span><span id="HATMaskBackbone-279"><a href="#HATMaskBackbone-279"><span class="linenos">279</span></a><span class="sd">        This method is used in the calculation of parameter-wise measure in various HAT-based algorithms:</span>
</span><span id="HATMaskBackbone-280"><a href="#HATMaskBackbone-280"><span class="linenos">280</span></a>
</span><span id="HATMaskBackbone-281"><a href="#HATMaskBackbone-281"><span class="linenos">281</span></a><span class="sd">        - **HAT**: the parameter-wise measure is the binary mask for previous tasks from the unit-wise cumulative mask of previous tasks `self.cumulative_mask_for_previous_tasks`, which is $\min \left(a_{l,i}^{&lt;t}, a_{l-1,j}^{&lt;t}\right)$ in equation (2) in [HAT paper](http://proceedings.mlr.press/v80/serra18a).</span>
</span><span id="HATMaskBackbone-282"><a href="#HATMaskBackbone-282"><span class="linenos">282</span></a><span class="sd">        - **AdaHAT**: the parameter-wise measure is the parameter importance for previous tasks from the unit-wise summative mask of previous tasks `self.summative_mask_for_previous_tasks`, which is $\min \left(m_{l,i}^{&lt;t,\text{sum}}, m_{l-1,j}^{&lt;t,\text{sum}}\right)$ in equation (9) in [AdaHAT paper](https://link.springer.com/chapter/10.1007/978-3-031-70352-2_9).</span>
</span><span id="HATMaskBackbone-283"><a href="#HATMaskBackbone-283"><span class="linenos">283</span></a><span class="sd">        - **CBPHAT**: the parameter-wise measure is the parameter importance for previous tasks from the unit-wise importance of previous tasks `self.unit_importance_for_previous_tasks` based on contribution utility, which is $\min \left(I_{l,i}^{(t-1)}, I_{l-1,j}^{(t-1)}\right)$ in the adjustment rate formula in the paper draft.</span>
</span><span id="HATMaskBackbone-284"><a href="#HATMaskBackbone-284"><span class="linenos">284</span></a>
</span><span id="HATMaskBackbone-285"><a href="#HATMaskBackbone-285"><span class="linenos">285</span></a><span class="sd">        **Args:**</span>
</span><span id="HATMaskBackbone-286"><a href="#HATMaskBackbone-286"><span class="linenos">286</span></a><span class="sd">        - **unit_wise_measure** (`dict[str, Tensor]`): the unit-wise measure. Key is layer name, value is the unit-wise measure tensor. The measure tensor has size (number of units).</span>
</span><span id="HATMaskBackbone-287"><a href="#HATMaskBackbone-287"><span class="linenos">287</span></a><span class="sd">        - **layer_name** (`str`): the name of given layer.</span>
</span><span id="HATMaskBackbone-288"><a href="#HATMaskBackbone-288"><span class="linenos">288</span></a><span class="sd">        - **aggregation** (`str`): the aggregation method turning two feature-wise measures into weight-wise matrix, should be one of the following:</span>
</span><span id="HATMaskBackbone-289"><a href="#HATMaskBackbone-289"><span class="linenos">289</span></a><span class="sd">            - &#39;min&#39;: takes minimum of the two connected unit measures.</span>
</span><span id="HATMaskBackbone-290"><a href="#HATMaskBackbone-290"><span class="linenos">290</span></a><span class="sd">            - &#39;max&#39;: takes maximum of the two connected unit measures.</span>
</span><span id="HATMaskBackbone-291"><a href="#HATMaskBackbone-291"><span class="linenos">291</span></a>
</span><span id="HATMaskBackbone-292"><a href="#HATMaskBackbone-292"><span class="linenos">292</span></a><span class="sd">        **Returns:**</span>
</span><span id="HATMaskBackbone-293"><a href="#HATMaskBackbone-293"><span class="linenos">293</span></a><span class="sd">        - **weight_measure** (`Tensor`): the weight measure matrix, same size as the corresponding weights.</span>
</span><span id="HATMaskBackbone-294"><a href="#HATMaskBackbone-294"><span class="linenos">294</span></a><span class="sd">        - **bias_measure** (`Tensor`): the bias measure vector, same size as the corresponding bias.</span>
</span><span id="HATMaskBackbone-295"><a href="#HATMaskBackbone-295"><span class="linenos">295</span></a>
</span><span id="HATMaskBackbone-296"><a href="#HATMaskBackbone-296"><span class="linenos">296</span></a>
</span><span id="HATMaskBackbone-297"><a href="#HATMaskBackbone-297"><span class="linenos">297</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="HATMaskBackbone-298"><a href="#HATMaskBackbone-298"><span class="linenos">298</span></a>
</span><span id="HATMaskBackbone-299"><a href="#HATMaskBackbone-299"><span class="linenos">299</span></a>        <span class="c1"># initialise the aggregation function</span>
</span><span id="HATMaskBackbone-300"><a href="#HATMaskBackbone-300"><span class="linenos">300</span></a>        <span class="k">if</span> <span class="n">aggregation</span> <span class="o">==</span> <span class="s2">&quot;min&quot;</span><span class="p">:</span>
</span><span id="HATMaskBackbone-301"><a href="#HATMaskBackbone-301"><span class="linenos">301</span></a>            <span class="n">aggregation_func</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">min</span>
</span><span id="HATMaskBackbone-302"><a href="#HATMaskBackbone-302"><span class="linenos">302</span></a>        <span class="k">elif</span> <span class="n">aggregation</span> <span class="o">==</span> <span class="s2">&quot;max&quot;</span><span class="p">:</span>
</span><span id="HATMaskBackbone-303"><a href="#HATMaskBackbone-303"><span class="linenos">303</span></a>            <span class="n">aggregation_func</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span>
</span><span id="HATMaskBackbone-304"><a href="#HATMaskBackbone-304"><span class="linenos">304</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="HATMaskBackbone-305"><a href="#HATMaskBackbone-305"><span class="linenos">305</span></a>            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The aggregation method </span><span class="si">{</span><span class="n">aggregation</span><span class="si">}</span><span class="s2"> is not supported.&quot;</span><span class="p">)</span>
</span><span id="HATMaskBackbone-306"><a href="#HATMaskBackbone-306"><span class="linenos">306</span></a>
</span><span id="HATMaskBackbone-307"><a href="#HATMaskBackbone-307"><span class="linenos">307</span></a>        <span class="c1"># get the preceding layer name</span>
</span><span id="HATMaskBackbone-308"><a href="#HATMaskBackbone-308"><span class="linenos">308</span></a>        <span class="n">preceding_layer_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preceding_layer_name</span><span class="p">(</span><span class="n">layer_name</span><span class="p">)</span>
</span><span id="HATMaskBackbone-309"><a href="#HATMaskBackbone-309"><span class="linenos">309</span></a>
</span><span id="HATMaskBackbone-310"><a href="#HATMaskBackbone-310"><span class="linenos">310</span></a>        <span class="c1"># get weight size for expanding the measures</span>
</span><span id="HATMaskBackbone-311"><a href="#HATMaskBackbone-311"><span class="linenos">311</span></a>        <span class="n">layer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_layer_by_name</span><span class="p">(</span><span class="n">layer_name</span><span class="p">)</span>
</span><span id="HATMaskBackbone-312"><a href="#HATMaskBackbone-312"><span class="linenos">312</span></a>        <span class="n">weight_size</span> <span class="o">=</span> <span class="n">layer</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
</span><span id="HATMaskBackbone-313"><a href="#HATMaskBackbone-313"><span class="linenos">313</span></a>
</span><span id="HATMaskBackbone-314"><a href="#HATMaskBackbone-314"><span class="linenos">314</span></a>        <span class="c1"># construct the weight-wise measure</span>
</span><span id="HATMaskBackbone-315"><a href="#HATMaskBackbone-315"><span class="linenos">315</span></a>        <span class="n">layer_measure</span> <span class="o">=</span> <span class="n">unit_wise_measure</span><span class="p">[</span><span class="n">layer_name</span><span class="p">]</span>
</span><span id="HATMaskBackbone-316"><a href="#HATMaskBackbone-316"><span class="linenos">316</span></a>        <span class="n">layer_measure_broadcast_size</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span>
</span><span id="HATMaskBackbone-317"><a href="#HATMaskBackbone-317"><span class="linenos">317</span></a>            <span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">weight_size</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
</span><span id="HATMaskBackbone-318"><a href="#HATMaskBackbone-318"><span class="linenos">318</span></a>        <span class="p">)</span>  <span class="c1"># since the size of mask tensor is (number of units), we extend it to (number of units, 1) and expand it to the weight size. The weight size has 2 dimensions in fully connected layers and 4 dimensions in convolutional layers</span>
</span><span id="HATMaskBackbone-319"><a href="#HATMaskBackbone-319"><span class="linenos">319</span></a>
</span><span id="HATMaskBackbone-320"><a href="#HATMaskBackbone-320"><span class="linenos">320</span></a>        <span class="n">layer_measure_broadcasted</span> <span class="o">=</span> <span class="n">layer_measure</span><span class="o">.</span><span class="n">view</span><span class="p">(</span>
</span><span id="HATMaskBackbone-321"><a href="#HATMaskBackbone-321"><span class="linenos">321</span></a>            <span class="o">*</span><span class="n">layer_measure_broadcast_size</span>
</span><span id="HATMaskBackbone-322"><a href="#HATMaskBackbone-322"><span class="linenos">322</span></a>        <span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span>
</span><span id="HATMaskBackbone-323"><a href="#HATMaskBackbone-323"><span class="linenos">323</span></a>            <span class="n">weight_size</span><span class="p">,</span>
</span><span id="HATMaskBackbone-324"><a href="#HATMaskBackbone-324"><span class="linenos">324</span></a>        <span class="p">)</span>  <span class="c1"># expand the given layer mask to the weight size and broadcast</span>
</span><span id="HATMaskBackbone-325"><a href="#HATMaskBackbone-325"><span class="linenos">325</span></a>
</span><span id="HATMaskBackbone-326"><a href="#HATMaskBackbone-326"><span class="linenos">326</span></a>        <span class="k">if</span> <span class="p">(</span>
</span><span id="HATMaskBackbone-327"><a href="#HATMaskBackbone-327"><span class="linenos">327</span></a>            <span class="n">preceding_layer_name</span>
</span><span id="HATMaskBackbone-328"><a href="#HATMaskBackbone-328"><span class="linenos">328</span></a>        <span class="p">):</span>  <span class="c1"># if the layer is not the first layer, where the preceding layer exists</span>
</span><span id="HATMaskBackbone-329"><a href="#HATMaskBackbone-329"><span class="linenos">329</span></a>
</span><span id="HATMaskBackbone-330"><a href="#HATMaskBackbone-330"><span class="linenos">330</span></a>            <span class="n">preceding_layer_measure_broadcast_size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span>
</span><span id="HATMaskBackbone-331"><a href="#HATMaskBackbone-331"><span class="linenos">331</span></a>                <span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">weight_size</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
</span><span id="HATMaskBackbone-332"><a href="#HATMaskBackbone-332"><span class="linenos">332</span></a>            <span class="p">)</span>  <span class="c1"># since the size of mask tensor is (number of units), we extend it to (1, number of units) and expand it to the weight size. The weight size has 2 dimensions in fully connected layers and 4 dimensions in convolutional layers</span>
</span><span id="HATMaskBackbone-333"><a href="#HATMaskBackbone-333"><span class="linenos">333</span></a>            <span class="n">preceding_layer_measure</span> <span class="o">=</span> <span class="n">unit_wise_measure</span><span class="p">[</span><span class="n">preceding_layer_name</span><span class="p">]</span>
</span><span id="HATMaskBackbone-334"><a href="#HATMaskBackbone-334"><span class="linenos">334</span></a>            <span class="n">preceding_layer_measure_broadcasted</span> <span class="o">=</span> <span class="n">preceding_layer_measure</span><span class="o">.</span><span class="n">view</span><span class="p">(</span>
</span><span id="HATMaskBackbone-335"><a href="#HATMaskBackbone-335"><span class="linenos">335</span></a>                <span class="o">*</span><span class="n">preceding_layer_measure_broadcast_size</span>
</span><span id="HATMaskBackbone-336"><a href="#HATMaskBackbone-336"><span class="linenos">336</span></a>            <span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span>
</span><span id="HATMaskBackbone-337"><a href="#HATMaskBackbone-337"><span class="linenos">337</span></a>                <span class="n">weight_size</span>
</span><span id="HATMaskBackbone-338"><a href="#HATMaskBackbone-338"><span class="linenos">338</span></a>            <span class="p">)</span>  <span class="c1"># expand the preceding layer mask to the weight size and broadcast</span>
</span><span id="HATMaskBackbone-339"><a href="#HATMaskBackbone-339"><span class="linenos">339</span></a>            <span class="n">weight_measure</span> <span class="o">=</span> <span class="n">aggregation_func</span><span class="p">(</span>
</span><span id="HATMaskBackbone-340"><a href="#HATMaskBackbone-340"><span class="linenos">340</span></a>                <span class="n">layer_measure_broadcasted</span><span class="p">,</span> <span class="n">preceding_layer_measure_broadcasted</span>
</span><span id="HATMaskBackbone-341"><a href="#HATMaskBackbone-341"><span class="linenos">341</span></a>            <span class="p">)</span>  <span class="c1"># get the minimum of the two mask vectors, from expanded</span>
</span><span id="HATMaskBackbone-342"><a href="#HATMaskBackbone-342"><span class="linenos">342</span></a>        <span class="k">else</span><span class="p">:</span>  <span class="c1"># if the layer is the first layer</span>
</span><span id="HATMaskBackbone-343"><a href="#HATMaskBackbone-343"><span class="linenos">343</span></a>            <span class="n">weight_measure</span> <span class="o">=</span> <span class="n">layer_measure_broadcasted</span>
</span><span id="HATMaskBackbone-344"><a href="#HATMaskBackbone-344"><span class="linenos">344</span></a>
</span><span id="HATMaskBackbone-345"><a href="#HATMaskBackbone-345"><span class="linenos">345</span></a>        <span class="c1"># construct the bias-wise measure</span>
</span><span id="HATMaskBackbone-346"><a href="#HATMaskBackbone-346"><span class="linenos">346</span></a>        <span class="n">bias_measure</span> <span class="o">=</span> <span class="n">layer_measure</span>
</span><span id="HATMaskBackbone-347"><a href="#HATMaskBackbone-347"><span class="linenos">347</span></a>
</span><span id="HATMaskBackbone-348"><a href="#HATMaskBackbone-348"><span class="linenos">348</span></a>        <span class="k">return</span> <span class="n">weight_measure</span><span class="p">,</span> <span class="n">bias_measure</span>
</span><span id="HATMaskBackbone-349"><a href="#HATMaskBackbone-349"><span class="linenos">349</span></a>
</span><span id="HATMaskBackbone-350"><a href="#HATMaskBackbone-350"><span class="linenos">350</span></a>    <span class="nd">@override</span>
</span><span id="HATMaskBackbone-351"><a href="#HATMaskBackbone-351"><span class="linenos">351</span></a>    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span>
</span><span id="HATMaskBackbone-352"><a href="#HATMaskBackbone-352"><span class="linenos">352</span></a>        <span class="bp">self</span><span class="p">,</span>
</span><span id="HATMaskBackbone-353"><a href="#HATMaskBackbone-353"><span class="linenos">353</span></a>        <span class="nb">input</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
</span><span id="HATMaskBackbone-354"><a href="#HATMaskBackbone-354"><span class="linenos">354</span></a>        <span class="n">stage</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
</span><span id="HATMaskBackbone-355"><a href="#HATMaskBackbone-355"><span class="linenos">355</span></a>        <span class="n">s_max</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
</span><span id="HATMaskBackbone-356"><a href="#HATMaskBackbone-356"><span class="linenos">356</span></a>        <span class="n">batch_idx</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
</span><span id="HATMaskBackbone-357"><a href="#HATMaskBackbone-357"><span class="linenos">357</span></a>        <span class="n">num_batches</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
</span><span id="HATMaskBackbone-358"><a href="#HATMaskBackbone-358"><span class="linenos">358</span></a>        <span class="n">test_mask</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
</span><span id="HATMaskBackbone-359"><a href="#HATMaskBackbone-359"><span class="linenos">359</span></a>    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]]:</span>
</span><span id="HATMaskBackbone-360"><a href="#HATMaskBackbone-360"><span class="linenos">360</span></a><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;The forward pass for data from task `task_id`. Task-specific mask for `task_id` are applied to the units in each layer.</span>
</span><span id="HATMaskBackbone-361"><a href="#HATMaskBackbone-361"><span class="linenos">361</span></a>
</span><span id="HATMaskBackbone-362"><a href="#HATMaskBackbone-362"><span class="linenos">362</span></a><span class="sd">        **Args:**</span>
</span><span id="HATMaskBackbone-363"><a href="#HATMaskBackbone-363"><span class="linenos">363</span></a><span class="sd">        - **input** (`Tensor`): The input tensor from data.</span>
</span><span id="HATMaskBackbone-364"><a href="#HATMaskBackbone-364"><span class="linenos">364</span></a><span class="sd">        - **stage** (`str`): the stage of the forward pass, should be one of the following:</span>
</span><span id="HATMaskBackbone-365"><a href="#HATMaskBackbone-365"><span class="linenos">365</span></a><span class="sd">            1. &#39;train&#39;: training stage.</span>
</span><span id="HATMaskBackbone-366"><a href="#HATMaskBackbone-366"><span class="linenos">366</span></a><span class="sd">            2. &#39;validation&#39;: validation stage.</span>
</span><span id="HATMaskBackbone-367"><a href="#HATMaskBackbone-367"><span class="linenos">367</span></a><span class="sd">            3. &#39;test&#39;: testing stage.</span>
</span><span id="HATMaskBackbone-368"><a href="#HATMaskBackbone-368"><span class="linenos">368</span></a><span class="sd">        - **s_max** (`float`): the maximum scaling factor in the gate function. See chapter 2.4 &quot;Hard Attention Training&quot; in [HAT paper](http://proceedings.mlr.press/v80/serra18a).</span>
</span><span id="HATMaskBackbone-369"><a href="#HATMaskBackbone-369"><span class="linenos">369</span></a><span class="sd">        - **batch_idx** (`int` | `None`): the current batch index. Applies only to training stage. For other stages, it is default `None`.</span>
</span><span id="HATMaskBackbone-370"><a href="#HATMaskBackbone-370"><span class="linenos">370</span></a><span class="sd">        - **num_batches** (`int` | `None`): the total number of batches. Applies only to training stage. For other stages, it is default `None`.</span>
</span><span id="HATMaskBackbone-371"><a href="#HATMaskBackbone-371"><span class="linenos">371</span></a><span class="sd">        - **test_mask** (`dict[str, Tensor]` | `None`): the binary mask used for test. Applies only to testing stage. For other stages, it is default `None`.</span>
</span><span id="HATMaskBackbone-372"><a href="#HATMaskBackbone-372"><span class="linenos">372</span></a>
</span><span id="HATMaskBackbone-373"><a href="#HATMaskBackbone-373"><span class="linenos">373</span></a><span class="sd">        **Returns:**</span>
</span><span id="HATMaskBackbone-374"><a href="#HATMaskBackbone-374"><span class="linenos">374</span></a><span class="sd">        - **output_feature** (`Tensor`): the output feature tensor to be passed into heads. This is the main target of backpropagation.</span>
</span><span id="HATMaskBackbone-375"><a href="#HATMaskBackbone-375"><span class="linenos">375</span></a><span class="sd">        - **mask** (`dict[str, Tensor]`): the mask for the current task. Key (`str`) is layer name, value (`Tensor`) is the mask tensor. The mask tensor has size (number of units).</span>
</span><span id="HATMaskBackbone-376"><a href="#HATMaskBackbone-376"><span class="linenos">376</span></a><span class="sd">        - **activations** (`dict[str, Tensor]`): the hidden features (after activation) in each weighted layer. Key (`str`) is the weighted layer name, value (`Tensor`) is the hidden feature tensor. This is used for the continual learning algorithms that need to use the hidden features for various purposes. Although HAT algorithm does not need this, it is still provided for API consistence for other HAT-based algorithms inherited this `forward()` method of `HAT` class.</span>
</span><span id="HATMaskBackbone-377"><a href="#HATMaskBackbone-377"><span class="linenos">377</span></a>
</span><span id="HATMaskBackbone-378"><a href="#HATMaskBackbone-378"><span class="linenos">378</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="HATMaskBackbone-379"><a href="#HATMaskBackbone-379"><span class="linenos">379</span></a>        <span class="c1"># this should be copied to all subclasses. Make sure it is called to get the mask for the current task from the task embedding in this stage</span>
</span><span id="HATMaskBackbone-380"><a href="#HATMaskBackbone-380"><span class="linenos">380</span></a>        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_mask</span><span class="p">(</span>
</span><span id="HATMaskBackbone-381"><a href="#HATMaskBackbone-381"><span class="linenos">381</span></a>            <span class="n">stage</span><span class="p">,</span>
</span><span id="HATMaskBackbone-382"><a href="#HATMaskBackbone-382"><span class="linenos">382</span></a>            <span class="n">s_max</span><span class="o">=</span><span class="n">s_max</span><span class="p">,</span>
</span><span id="HATMaskBackbone-383"><a href="#HATMaskBackbone-383"><span class="linenos">383</span></a>            <span class="n">batch_idx</span><span class="o">=</span><span class="n">batch_idx</span><span class="p">,</span>
</span><span id="HATMaskBackbone-384"><a href="#HATMaskBackbone-384"><span class="linenos">384</span></a>            <span class="n">num_batches</span><span class="o">=</span><span class="n">num_batches</span><span class="p">,</span>
</span><span id="HATMaskBackbone-385"><a href="#HATMaskBackbone-385"><span class="linenos">385</span></a>            <span class="n">test_mask</span><span class="o">=</span><span class="n">test_mask</span><span class="p">,</span>
</span><span id="HATMaskBackbone-386"><a href="#HATMaskBackbone-386"><span class="linenos">386</span></a>        <span class="p">)</span>
</span></pre></div>


            <div class="docstring"><p>The backbone network for HAT-based algorithms with learnable hard attention masks.</p>

<p>HAT-based algorithms:</p>

<ul>
<li><a href="http://proceedings.mlr.press/v80/serra18a"><strong>HAT (Hard Attention to the Task, 2018)</strong></a> is an architecture-based continual learning approach that uses learnable hard attention masks to select the task-specific parameters.</li>
<li><a href="https://link.springer.com/chapter/10.1007/978-3-031-70352-2_9"><strong>Adaptive HAT (Adaptive Hard Attention to the Task, 2024)</strong></a> is an architecture-based continual learning approach that improves <a href="http://proceedings.mlr.press/v80/serra18a">HAT (Hard Attention to the Task, 2018)</a> by introducing new adaptive soft gradient clipping based on parameter importance and network sparsity.</li>
<li><strong>CBPHAT</strong> is what I am working on, trying combining HAT (Hard Attention to the Task) algorithm with Continual Backpropagation (CBP) by leveraging the contribution utility as the parameter importance like in AdaHAT (Adaptive Hard Attention to the Task) algorithm.</li>
</ul>
</div>


                            <div id="HATMaskBackbone.__init__" class="classattr">
                                        <input id="HATMaskBackbone.__init__-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="name">HATMaskBackbone</span><span class="signature pdoc-code condensed">(<span class="param"><span class="n">output_dim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span>, </span><span class="param"><span class="n">gate</span><span class="p">:</span> <span class="nb">str</span></span>)</span>

                <label class="view-source-button" for="HATMaskBackbone.__init__-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#HATMaskBackbone.__init__"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="HATMaskBackbone.__init__-118"><a href="#HATMaskBackbone.__init__-118"><span class="linenos">118</span></a>    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_dim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">gate</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="HATMaskBackbone.__init__-119"><a href="#HATMaskBackbone.__init__-119"><span class="linenos">119</span></a><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Initialise the HAT mask backbone network with task embeddings and masks.</span>
</span><span id="HATMaskBackbone.__init__-120"><a href="#HATMaskBackbone.__init__-120"><span class="linenos">120</span></a>
</span><span id="HATMaskBackbone.__init__-121"><a href="#HATMaskBackbone.__init__-121"><span class="linenos">121</span></a><span class="sd">        **Args:**</span>
</span><span id="HATMaskBackbone.__init__-122"><a href="#HATMaskBackbone.__init__-122"><span class="linenos">122</span></a><span class="sd">        - **output_dim** (`int`): The output dimension which connects to CL output heads. The `input_dim` of output heads are expected to be the same as this `output_dim`. In some cases, this class is used for a block in the backbone network, which doesn&#39;t have the output dimension. In this case, it can be `None`.</span>
</span><span id="HATMaskBackbone.__init__-123"><a href="#HATMaskBackbone.__init__-123"><span class="linenos">123</span></a><span class="sd">        - **gate** (`str`): the type of gate function turning the real value task embeddings into attention masks, should be one of the following:</span>
</span><span id="HATMaskBackbone.__init__-124"><a href="#HATMaskBackbone.__init__-124"><span class="linenos">124</span></a><span class="sd">            - `sigmoid`: the sigmoid function.</span>
</span><span id="HATMaskBackbone.__init__-125"><a href="#HATMaskBackbone.__init__-125"><span class="linenos">125</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="HATMaskBackbone.__init__-126"><a href="#HATMaskBackbone.__init__-126"><span class="linenos">126</span></a>        <span class="n">CLBackbone</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_dim</span><span class="o">=</span><span class="n">output_dim</span><span class="p">)</span>
</span><span id="HATMaskBackbone.__init__-127"><a href="#HATMaskBackbone.__init__-127"><span class="linenos">127</span></a>
</span><span id="HATMaskBackbone.__init__-128"><a href="#HATMaskBackbone.__init__-128"><span class="linenos">128</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">register_hat_mask_module_explicitly</span><span class="p">(</span>
</span><span id="HATMaskBackbone.__init__-129"><a href="#HATMaskBackbone.__init__-129"><span class="linenos">129</span></a>            <span class="n">gate</span><span class="o">=</span><span class="n">gate</span>
</span><span id="HATMaskBackbone.__init__-130"><a href="#HATMaskBackbone.__init__-130"><span class="linenos">130</span></a>        <span class="p">)</span>  <span class="c1"># we moved the registration of the modules to a separate method to solve a problem of multiple inheritance in terms of `nn.Module`</span>
</span><span id="HATMaskBackbone.__init__-131"><a href="#HATMaskBackbone.__init__-131"><span class="linenos">131</span></a>
</span><span id="HATMaskBackbone.__init__-132"><a href="#HATMaskBackbone.__init__-132"><span class="linenos">132</span></a>        <span class="n">HATMaskBackbone</span><span class="o">.</span><span class="n">sanity_check</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</span></pre></div>


            <div class="docstring"><p>Initialise the HAT mask backbone network with task embeddings and masks.</p>

<p><strong>Args:</strong></p>

<ul>
<li><strong>output_dim</strong> (<code>int</code>): The output dimension which connects to CL output heads. The <code>input_dim</code> of output heads are expected to be the same as this <code><a href="#HATMaskBackbone.output_dim">output_dim</a></code>. In some cases, this class is used for a block in the backbone network, which doesn't have the output dimension. In this case, it can be <code>None</code>.</li>
<li><strong>gate</strong> (<code>str</code>): the type of gate function turning the real value task embeddings into attention masks, should be one of the following:
<ul>
<li><code>sigmoid</code>: the sigmoid function.</li>
</ul></li>
</ul>
</div>


                            </div>
                            <div id="HATMaskBackbone.register_hat_mask_module_explicitly" class="classattr">
                                        <input id="HATMaskBackbone.register_hat_mask_module_explicitly-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">register_hat_mask_module_explicitly</span><span class="signature pdoc-code condensed">(<span class="param"><span class="bp">self</span>, </span><span class="param"><span class="n">gate</span><span class="p">:</span> <span class="nb">str</span></span><span class="return-annotation">) -> <span class="kc">None</span>:</span></span>

                <label class="view-source-button" for="HATMaskBackbone.register_hat_mask_module_explicitly-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#HATMaskBackbone.register_hat_mask_module_explicitly"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="HATMaskBackbone.register_hat_mask_module_explicitly-134"><a href="#HATMaskBackbone.register_hat_mask_module_explicitly-134"><span class="linenos">134</span></a>    <span class="k">def</span><span class="w"> </span><span class="nf">register_hat_mask_module_explicitly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gate</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="HATMaskBackbone.register_hat_mask_module_explicitly-135"><a href="#HATMaskBackbone.register_hat_mask_module_explicitly-135"><span class="linenos">135</span></a><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Register all `nn.Module`s explicitly in this method. For `HATMaskBackbone`, they are task embedding for the current task and the masks.</span>
</span><span id="HATMaskBackbone.register_hat_mask_module_explicitly-136"><a href="#HATMaskBackbone.register_hat_mask_module_explicitly-136"><span class="linenos">136</span></a>
</span><span id="HATMaskBackbone.register_hat_mask_module_explicitly-137"><a href="#HATMaskBackbone.register_hat_mask_module_explicitly-137"><span class="linenos">137</span></a><span class="sd">        **Args:**</span>
</span><span id="HATMaskBackbone.register_hat_mask_module_explicitly-138"><a href="#HATMaskBackbone.register_hat_mask_module_explicitly-138"><span class="linenos">138</span></a><span class="sd">        - **gate** (`str`): the type of gate function turning the real value task embeddings into attention masks, should be one of the following:</span>
</span><span id="HATMaskBackbone.register_hat_mask_module_explicitly-139"><a href="#HATMaskBackbone.register_hat_mask_module_explicitly-139"><span class="linenos">139</span></a><span class="sd">            - `sigmoid`: the sigmoid function.</span>
</span><span id="HATMaskBackbone.register_hat_mask_module_explicitly-140"><a href="#HATMaskBackbone.register_hat_mask_module_explicitly-140"><span class="linenos">140</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="HATMaskBackbone.register_hat_mask_module_explicitly-141"><a href="#HATMaskBackbone.register_hat_mask_module_explicitly-141"><span class="linenos">141</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">gate</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">gate</span>
</span><span id="HATMaskBackbone.register_hat_mask_module_explicitly-142"><a href="#HATMaskBackbone.register_hat_mask_module_explicitly-142"><span class="linenos">142</span></a><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Store the type of gate function.&quot;&quot;&quot;</span>
</span><span id="HATMaskBackbone.register_hat_mask_module_explicitly-143"><a href="#HATMaskBackbone.register_hat_mask_module_explicitly-143"><span class="linenos">143</span></a>        <span class="k">if</span> <span class="n">gate</span> <span class="o">==</span> <span class="s2">&quot;sigmoid&quot;</span><span class="p">:</span>
</span><span id="HATMaskBackbone.register_hat_mask_module_explicitly-144"><a href="#HATMaskBackbone.register_hat_mask_module_explicitly-144"><span class="linenos">144</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">gate_fn</span><span class="p">:</span> <span class="n">nn</span><span class="o">.</span><span class="n">Module</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sigmoid</span><span class="p">()</span>
</span><span id="HATMaskBackbone.register_hat_mask_module_explicitly-145"><a href="#HATMaskBackbone.register_hat_mask_module_explicitly-145"><span class="linenos">145</span></a><span class="w">            </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;The gate function turning the real value task embeddings into attention masks.&quot;&quot;&quot;</span>
</span><span id="HATMaskBackbone.register_hat_mask_module_explicitly-146"><a href="#HATMaskBackbone.register_hat_mask_module_explicitly-146"><span class="linenos">146</span></a>
</span><span id="HATMaskBackbone.register_hat_mask_module_explicitly-147"><a href="#HATMaskBackbone.register_hat_mask_module_explicitly-147"><span class="linenos">147</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">task_embedding_t</span><span class="p">:</span> <span class="n">nn</span><span class="o">.</span><span class="n">ModuleDict</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">ModuleDict</span><span class="p">()</span>
</span><span id="HATMaskBackbone.register_hat_mask_module_explicitly-148"><a href="#HATMaskBackbone.register_hat_mask_module_explicitly-148"><span class="linenos">148</span></a><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Store the task embedding for the current task. Keys are the layer names and values are the task embedding `nn.Embedding` for the layer. Each task embedding has size (1, number of units).</span>
</span><span id="HATMaskBackbone.register_hat_mask_module_explicitly-149"><a href="#HATMaskBackbone.register_hat_mask_module_explicitly-149"><span class="linenos">149</span></a><span class="sd">        </span>
</span><span id="HATMaskBackbone.register_hat_mask_module_explicitly-150"><a href="#HATMaskBackbone.register_hat_mask_module_explicitly-150"><span class="linenos">150</span></a><span class="sd">        We use `ModuleDict` rather than `dict` to make sure `LightningModule` can properly register these model parameters for the purpose of, like automatically transfering to device, being recorded in model summaries.</span>
</span><span id="HATMaskBackbone.register_hat_mask_module_explicitly-151"><a href="#HATMaskBackbone.register_hat_mask_module_explicitly-151"><span class="linenos">151</span></a><span class="sd">        </span>
</span><span id="HATMaskBackbone.register_hat_mask_module_explicitly-152"><a href="#HATMaskBackbone.register_hat_mask_module_explicitly-152"><span class="linenos">152</span></a><span class="sd">        we use `nn.Embedding` rather than `nn.Parameter` to store the task embedding for each layer, which is a type of `nn.Module` and can be accepted by `nn.ModuleDict`. (`nn.Parameter` cannot be accepted by `nn.ModuleDict`.)</span>
</span><span id="HATMaskBackbone.register_hat_mask_module_explicitly-153"><a href="#HATMaskBackbone.register_hat_mask_module_explicitly-153"><span class="linenos">153</span></a><span class="sd">        </span>
</span><span id="HATMaskBackbone.register_hat_mask_module_explicitly-154"><a href="#HATMaskBackbone.register_hat_mask_module_explicitly-154"><span class="linenos">154</span></a><span class="sd">        **This must be defined to cover each weighted layer (just as `self.weighted_layer_names` listed) in the backbone network.** Otherwise, the uncovered parts will keep updating for all tasks and become a source of catastrophic forgetting. &quot;&quot;&quot;</span>
</span></pre></div>


            <div class="docstring"><p>Register all <code>nn.Module</code>s explicitly in this method. For <code><a href="#HATMaskBackbone">HATMaskBackbone</a></code>, they are task embedding for the current task and the masks.</p>

<p><strong>Args:</strong></p>

<ul>
<li><strong>gate</strong> (<code>str</code>): the type of gate function turning the real value task embeddings into attention masks, should be one of the following:
<ul>
<li><code>sigmoid</code>: the sigmoid function.</li>
</ul></li>
</ul>
</div>


                            </div>
                            <div id="HATMaskBackbone.initialise_task_embedding" class="classattr">
                                        <input id="HATMaskBackbone.initialise_task_embedding-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">initialise_task_embedding</span><span class="signature pdoc-code condensed">(<span class="param"><span class="bp">self</span>, </span><span class="param"><span class="n">mode</span><span class="p">:</span> <span class="nb">str</span></span><span class="return-annotation">) -> <span class="kc">None</span>:</span></span>

                <label class="view-source-button" for="HATMaskBackbone.initialise_task_embedding-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#HATMaskBackbone.initialise_task_embedding"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="HATMaskBackbone.initialise_task_embedding-156"><a href="#HATMaskBackbone.initialise_task_embedding-156"><span class="linenos">156</span></a>    <span class="k">def</span><span class="w"> </span><span class="nf">initialise_task_embedding</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="HATMaskBackbone.initialise_task_embedding-157"><a href="#HATMaskBackbone.initialise_task_embedding-157"><span class="linenos">157</span></a><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Initialise the task embedding for the current task.</span>
</span><span id="HATMaskBackbone.initialise_task_embedding-158"><a href="#HATMaskBackbone.initialise_task_embedding-158"><span class="linenos">158</span></a>
</span><span id="HATMaskBackbone.initialise_task_embedding-159"><a href="#HATMaskBackbone.initialise_task_embedding-159"><span class="linenos">159</span></a><span class="sd">        **Args:**</span>
</span><span id="HATMaskBackbone.initialise_task_embedding-160"><a href="#HATMaskBackbone.initialise_task_embedding-160"><span class="linenos">160</span></a><span class="sd">        - **mode** (`str`): the initialisation mode for task embeddings, should be one of the following:</span>
</span><span id="HATMaskBackbone.initialise_task_embedding-161"><a href="#HATMaskBackbone.initialise_task_embedding-161"><span class="linenos">161</span></a><span class="sd">            1. &#39;N01&#39; (default): standard normal distribution $N(0, 1)$.</span>
</span><span id="HATMaskBackbone.initialise_task_embedding-162"><a href="#HATMaskBackbone.initialise_task_embedding-162"><span class="linenos">162</span></a><span class="sd">            2. &#39;U-11&#39;: uniform distribution $U(-1, 1)$.</span>
</span><span id="HATMaskBackbone.initialise_task_embedding-163"><a href="#HATMaskBackbone.initialise_task_embedding-163"><span class="linenos">163</span></a><span class="sd">            3. &#39;U01&#39;: uniform distribution $U(0, 1)$.</span>
</span><span id="HATMaskBackbone.initialise_task_embedding-164"><a href="#HATMaskBackbone.initialise_task_embedding-164"><span class="linenos">164</span></a><span class="sd">            4. &#39;U-10&#39;: uniform distribution $U(-1, 0)$.</span>
</span><span id="HATMaskBackbone.initialise_task_embedding-165"><a href="#HATMaskBackbone.initialise_task_embedding-165"><span class="linenos">165</span></a><span class="sd">            5. &#39;last&#39;: inherit task embedding from last task.</span>
</span><span id="HATMaskBackbone.initialise_task_embedding-166"><a href="#HATMaskBackbone.initialise_task_embedding-166"><span class="linenos">166</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="HATMaskBackbone.initialise_task_embedding-167"><a href="#HATMaskBackbone.initialise_task_embedding-167"><span class="linenos">167</span></a>        <span class="k">for</span> <span class="n">te</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">task_embedding_t</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
</span><span id="HATMaskBackbone.initialise_task_embedding-168"><a href="#HATMaskBackbone.initialise_task_embedding-168"><span class="linenos">168</span></a>            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;N01&quot;</span><span class="p">:</span>
</span><span id="HATMaskBackbone.initialise_task_embedding-169"><a href="#HATMaskBackbone.initialise_task_embedding-169"><span class="linenos">169</span></a>                <span class="n">nn</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">normal_</span><span class="p">(</span><span class="n">te</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span><span id="HATMaskBackbone.initialise_task_embedding-170"><a href="#HATMaskBackbone.initialise_task_embedding-170"><span class="linenos">170</span></a>            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;U-11&quot;</span><span class="p">:</span>
</span><span id="HATMaskBackbone.initialise_task_embedding-171"><a href="#HATMaskBackbone.initialise_task_embedding-171"><span class="linenos">171</span></a>                <span class="n">nn</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">uniform_</span><span class="p">(</span><span class="n">te</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span><span id="HATMaskBackbone.initialise_task_embedding-172"><a href="#HATMaskBackbone.initialise_task_embedding-172"><span class="linenos">172</span></a>            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;U01&quot;</span><span class="p">:</span>
</span><span id="HATMaskBackbone.initialise_task_embedding-173"><a href="#HATMaskBackbone.initialise_task_embedding-173"><span class="linenos">173</span></a>                <span class="n">nn</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">uniform_</span><span class="p">(</span><span class="n">te</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span><span id="HATMaskBackbone.initialise_task_embedding-174"><a href="#HATMaskBackbone.initialise_task_embedding-174"><span class="linenos">174</span></a>            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;U-10&quot;</span><span class="p">:</span>
</span><span id="HATMaskBackbone.initialise_task_embedding-175"><a href="#HATMaskBackbone.initialise_task_embedding-175"><span class="linenos">175</span></a>                <span class="n">nn</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">uniform_</span><span class="p">(</span><span class="n">te</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span><span id="HATMaskBackbone.initialise_task_embedding-176"><a href="#HATMaskBackbone.initialise_task_embedding-176"><span class="linenos">176</span></a>            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;last&quot;</span><span class="p">:</span>
</span><span id="HATMaskBackbone.initialise_task_embedding-177"><a href="#HATMaskBackbone.initialise_task_embedding-177"><span class="linenos">177</span></a>                <span class="k">pass</span>
</span></pre></div>


            <div class="docstring"><p>Initialise the task embedding for the current task.</p>

<p><strong>Args:</strong></p>

<ul>
<li><strong>mode</strong> (<code>str</code>): the initialisation mode for task embeddings, should be one of the following:
<ol>
<li>'N01' (default): standard normal distribution $N(0, 1)$.</li>
<li>'U-11': uniform distribution $U(-1, 1)$.</li>
<li>'U01': uniform distribution $U(0, 1)$.</li>
<li>'U-10': uniform distribution $U(-1, 0)$.</li>
<li>'last': inherit task embedding from last task.</li>
</ol></li>
</ul>
</div>


                            </div>
                            <div id="HATMaskBackbone.sanity_check" class="classattr">
                                        <input id="HATMaskBackbone.sanity_check-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">sanity_check</span><span class="signature pdoc-code condensed">(<span class="param"><span class="bp">self</span></span><span class="return-annotation">) -> <span class="kc">None</span>:</span></span>

                <label class="view-source-button" for="HATMaskBackbone.sanity_check-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#HATMaskBackbone.sanity_check"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="HATMaskBackbone.sanity_check-179"><a href="#HATMaskBackbone.sanity_check-179"><span class="linenos">179</span></a>    <span class="k">def</span><span class="w"> </span><span class="nf">sanity_check</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="HATMaskBackbone.sanity_check-180"><a href="#HATMaskBackbone.sanity_check-180"><span class="linenos">180</span></a><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Check the sanity of the arguments.</span>
</span><span id="HATMaskBackbone.sanity_check-181"><a href="#HATMaskBackbone.sanity_check-181"><span class="linenos">181</span></a>
</span><span id="HATMaskBackbone.sanity_check-182"><a href="#HATMaskBackbone.sanity_check-182"><span class="linenos">182</span></a><span class="sd">        **Raises:**</span>
</span><span id="HATMaskBackbone.sanity_check-183"><a href="#HATMaskBackbone.sanity_check-183"><span class="linenos">183</span></a><span class="sd">        - **ValueError**: when the `gate` is not one of the valid options.</span>
</span><span id="HATMaskBackbone.sanity_check-184"><a href="#HATMaskBackbone.sanity_check-184"><span class="linenos">184</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="HATMaskBackbone.sanity_check-185"><a href="#HATMaskBackbone.sanity_check-185"><span class="linenos">185</span></a>
</span><span id="HATMaskBackbone.sanity_check-186"><a href="#HATMaskBackbone.sanity_check-186"><span class="linenos">186</span></a>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gate</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;sigmoid&quot;</span><span class="p">]:</span>
</span><span id="HATMaskBackbone.sanity_check-187"><a href="#HATMaskBackbone.sanity_check-187"><span class="linenos">187</span></a>            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The gate should be one of &#39;sigmoid&#39;.&quot;</span><span class="p">)</span>
</span></pre></div>


            <div class="docstring"><p>Check the sanity of the arguments.</p>

<p><strong>Raises:</strong></p>

<ul>
<li><strong>ValueError</strong>: when the <code>gate</code> is not one of the valid options.</li>
</ul>
</div>


                            </div>
                            <div id="HATMaskBackbone.get_mask" class="classattr">
                                        <input id="HATMaskBackbone.get_mask-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">get_mask</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="bp">self</span>,</span><span class="param">	<span class="n">stage</span><span class="p">:</span> <span class="nb">str</span>,</span><span class="param">	<span class="n">s_max</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>,</span><span class="param">	<span class="n">batch_idx</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>,</span><span class="param">	<span class="n">num_batches</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>,</span><span class="param">	<span class="n">test_mask</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span></span><span class="return-annotation">) -> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span>:</span></span>

                <label class="view-source-button" for="HATMaskBackbone.get_mask-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#HATMaskBackbone.get_mask"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="HATMaskBackbone.get_mask-189"><a href="#HATMaskBackbone.get_mask-189"><span class="linenos">189</span></a>    <span class="k">def</span><span class="w"> </span><span class="nf">get_mask</span><span class="p">(</span>
</span><span id="HATMaskBackbone.get_mask-190"><a href="#HATMaskBackbone.get_mask-190"><span class="linenos">190</span></a>        <span class="bp">self</span><span class="p">,</span>
</span><span id="HATMaskBackbone.get_mask-191"><a href="#HATMaskBackbone.get_mask-191"><span class="linenos">191</span></a>        <span class="n">stage</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
</span><span id="HATMaskBackbone.get_mask-192"><a href="#HATMaskBackbone.get_mask-192"><span class="linenos">192</span></a>        <span class="n">s_max</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
</span><span id="HATMaskBackbone.get_mask-193"><a href="#HATMaskBackbone.get_mask-193"><span class="linenos">193</span></a>        <span class="n">batch_idx</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
</span><span id="HATMaskBackbone.get_mask-194"><a href="#HATMaskBackbone.get_mask-194"><span class="linenos">194</span></a>        <span class="n">num_batches</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
</span><span id="HATMaskBackbone.get_mask-195"><a href="#HATMaskBackbone.get_mask-195"><span class="linenos">195</span></a>        <span class="n">test_mask</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
</span><span id="HATMaskBackbone.get_mask-196"><a href="#HATMaskBackbone.get_mask-196"><span class="linenos">196</span></a>    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]:</span>
</span><span id="HATMaskBackbone.get_mask-197"><a href="#HATMaskBackbone.get_mask-197"><span class="linenos">197</span></a><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Get the hard attention mask used in `forward()` method for different stages.</span>
</span><span id="HATMaskBackbone.get_mask-198"><a href="#HATMaskBackbone.get_mask-198"><span class="linenos">198</span></a>
</span><span id="HATMaskBackbone.get_mask-199"><a href="#HATMaskBackbone.get_mask-199"><span class="linenos">199</span></a><span class="sd">        **Args:**</span>
</span><span id="HATMaskBackbone.get_mask-200"><a href="#HATMaskBackbone.get_mask-200"><span class="linenos">200</span></a><span class="sd">        - **stage** (`str`): the stage when applying the conversion, should be one of the following:</span>
</span><span id="HATMaskBackbone.get_mask-201"><a href="#HATMaskBackbone.get_mask-201"><span class="linenos">201</span></a><span class="sd">            1. &#39;train&#39;: training stage. If stage is &#39;train&#39;, get the mask from task embedding of current task through the gate function, which is scaled by an annealed scalar. See chapter 2.4 &quot;Hard Attention Training&quot; in [HAT paper](http://proceedings.mlr.press/v80/serra18a).</span>
</span><span id="HATMaskBackbone.get_mask-202"><a href="#HATMaskBackbone.get_mask-202"><span class="linenos">202</span></a><span class="sd">            2. ‘validation&#39;: validation stage. If stage is &#39;validation&#39;, get the mask from task embedding of current task through the gate function, which is scaled by `s_max`. (Note that in this stage, the binary mask hasn&#39;t been stored yet as the training is not over.)</span>
</span><span id="HATMaskBackbone.get_mask-203"><a href="#HATMaskBackbone.get_mask-203"><span class="linenos">203</span></a><span class="sd">            3. &#39;test&#39;: testing stage. If stage is &#39;test&#39;, apply the mask gate function is scaled by `s_max`, the large scaling making masks nearly binary.</span>
</span><span id="HATMaskBackbone.get_mask-204"><a href="#HATMaskBackbone.get_mask-204"><span class="linenos">204</span></a><span class="sd">        - **s_max** (`float`): the maximum scaling factor in the gate function. Doesn&#39;t apply to testing stage. See chapter 2.4 &quot;Hard Attention Training&quot; in [HAT paper](http://proceedings.mlr.press/v80/serra18a).</span>
</span><span id="HATMaskBackbone.get_mask-205"><a href="#HATMaskBackbone.get_mask-205"><span class="linenos">205</span></a><span class="sd">        - **batch_idx** (`int` | `None`): the current batch index. Applies only to training stage. For other stages, it is default `None`.</span>
</span><span id="HATMaskBackbone.get_mask-206"><a href="#HATMaskBackbone.get_mask-206"><span class="linenos">206</span></a><span class="sd">        - **num_batches** (`int` | `None`): the total number of batches. Applies only to training stage. For other stages, it is default `None`.</span>
</span><span id="HATMaskBackbone.get_mask-207"><a href="#HATMaskBackbone.get_mask-207"><span class="linenos">207</span></a><span class="sd">        - **test_mask** (`dict[str, Tensor]` | `None`): the binary mask used for test. Applies only to testing stage. For other stages, it is default `None`.</span>
</span><span id="HATMaskBackbone.get_mask-208"><a href="#HATMaskBackbone.get_mask-208"><span class="linenos">208</span></a>
</span><span id="HATMaskBackbone.get_mask-209"><a href="#HATMaskBackbone.get_mask-209"><span class="linenos">209</span></a><span class="sd">        **Returns:**</span>
</span><span id="HATMaskBackbone.get_mask-210"><a href="#HATMaskBackbone.get_mask-210"><span class="linenos">210</span></a><span class="sd">        - **mask** (`dict[str, Tensor]`): the hard attention (whose values are 0 or 1) mask. Key (`str`) is layer name, value (`Tensor`) is the mask tensor. The mask tensor has size (number of units).</span>
</span><span id="HATMaskBackbone.get_mask-211"><a href="#HATMaskBackbone.get_mask-211"><span class="linenos">211</span></a>
</span><span id="HATMaskBackbone.get_mask-212"><a href="#HATMaskBackbone.get_mask-212"><span class="linenos">212</span></a><span class="sd">        **Raises:**</span>
</span><span id="HATMaskBackbone.get_mask-213"><a href="#HATMaskBackbone.get_mask-213"><span class="linenos">213</span></a><span class="sd">        - **ValueError**: if the `batch_idx` and `batch_num` are not provided in &#39;train&#39; stage; if the `s_max` is not provided in &#39;validation&#39; stage; if the `task_id` is not provided in &#39;test&#39; stage.</span>
</span><span id="HATMaskBackbone.get_mask-214"><a href="#HATMaskBackbone.get_mask-214"><span class="linenos">214</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="HATMaskBackbone.get_mask-215"><a href="#HATMaskBackbone.get_mask-215"><span class="linenos">215</span></a>
</span><span id="HATMaskBackbone.get_mask-216"><a href="#HATMaskBackbone.get_mask-216"><span class="linenos">216</span></a>        <span class="c1"># sanity check</span>
</span><span id="HATMaskBackbone.get_mask-217"><a href="#HATMaskBackbone.get_mask-217"><span class="linenos">217</span></a>        <span class="k">if</span> <span class="n">stage</span> <span class="o">==</span> <span class="s2">&quot;train&quot;</span> <span class="ow">and</span> <span class="p">(</span>
</span><span id="HATMaskBackbone.get_mask-218"><a href="#HATMaskBackbone.get_mask-218"><span class="linenos">218</span></a>            <span class="n">s_max</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">batch_idx</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">num_batches</span> <span class="ow">is</span> <span class="kc">None</span>
</span><span id="HATMaskBackbone.get_mask-219"><a href="#HATMaskBackbone.get_mask-219"><span class="linenos">219</span></a>        <span class="p">):</span>
</span><span id="HATMaskBackbone.get_mask-220"><a href="#HATMaskBackbone.get_mask-220"><span class="linenos">220</span></a>            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
</span><span id="HATMaskBackbone.get_mask-221"><a href="#HATMaskBackbone.get_mask-221"><span class="linenos">221</span></a>                <span class="s2">&quot;The `s_max`, `batch_idx` and `batch_num` should be provided at training stage, instead of the default value `None`.&quot;</span>
</span><span id="HATMaskBackbone.get_mask-222"><a href="#HATMaskBackbone.get_mask-222"><span class="linenos">222</span></a>            <span class="p">)</span>
</span><span id="HATMaskBackbone.get_mask-223"><a href="#HATMaskBackbone.get_mask-223"><span class="linenos">223</span></a>        <span class="k">if</span> <span class="n">stage</span> <span class="o">==</span> <span class="s2">&quot;validation&quot;</span> <span class="ow">and</span> <span class="p">(</span><span class="n">s_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
</span><span id="HATMaskBackbone.get_mask-224"><a href="#HATMaskBackbone.get_mask-224"><span class="linenos">224</span></a>            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
</span><span id="HATMaskBackbone.get_mask-225"><a href="#HATMaskBackbone.get_mask-225"><span class="linenos">225</span></a>                <span class="s2">&quot;The `s_max` should be provided at validation stage, instead of the default value `None`.&quot;</span>
</span><span id="HATMaskBackbone.get_mask-226"><a href="#HATMaskBackbone.get_mask-226"><span class="linenos">226</span></a>            <span class="p">)</span>
</span><span id="HATMaskBackbone.get_mask-227"><a href="#HATMaskBackbone.get_mask-227"><span class="linenos">227</span></a>        <span class="k">if</span> <span class="n">stage</span> <span class="o">==</span> <span class="s2">&quot;test&quot;</span> <span class="ow">and</span> <span class="p">(</span><span class="n">test_mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
</span><span id="HATMaskBackbone.get_mask-228"><a href="#HATMaskBackbone.get_mask-228"><span class="linenos">228</span></a>            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
</span><span id="HATMaskBackbone.get_mask-229"><a href="#HATMaskBackbone.get_mask-229"><span class="linenos">229</span></a>                <span class="s2">&quot;The `task_mask` should be provided at testing stage, instead of the default value `None`.&quot;</span>
</span><span id="HATMaskBackbone.get_mask-230"><a href="#HATMaskBackbone.get_mask-230"><span class="linenos">230</span></a>            <span class="p">)</span>
</span><span id="HATMaskBackbone.get_mask-231"><a href="#HATMaskBackbone.get_mask-231"><span class="linenos">231</span></a>
</span><span id="HATMaskBackbone.get_mask-232"><a href="#HATMaskBackbone.get_mask-232"><span class="linenos">232</span></a>        <span class="n">mask</span> <span class="o">=</span> <span class="p">{}</span>
</span><span id="HATMaskBackbone.get_mask-233"><a href="#HATMaskBackbone.get_mask-233"><span class="linenos">233</span></a>        <span class="k">if</span> <span class="n">stage</span> <span class="o">==</span> <span class="s2">&quot;train&quot;</span><span class="p">:</span>
</span><span id="HATMaskBackbone.get_mask-234"><a href="#HATMaskBackbone.get_mask-234"><span class="linenos">234</span></a>            <span class="k">for</span> <span class="n">layer_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted_layer_names</span><span class="p">:</span>
</span><span id="HATMaskBackbone.get_mask-235"><a href="#HATMaskBackbone.get_mask-235"><span class="linenos">235</span></a>                <span class="n">anneal_scalar</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">s_max</span> <span class="o">+</span> <span class="p">(</span><span class="n">s_max</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">s_max</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">batch_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span>
</span><span id="HATMaskBackbone.get_mask-236"><a href="#HATMaskBackbone.get_mask-236"><span class="linenos">236</span></a>                    <span class="n">num_batches</span> <span class="o">-</span> <span class="mi">1</span>
</span><span id="HATMaskBackbone.get_mask-237"><a href="#HATMaskBackbone.get_mask-237"><span class="linenos">237</span></a>                <span class="p">)</span>  <span class="c1"># see equation (3) in chapter 2.4 &quot;Hard Attention Training&quot; in [HAT paper](http://proceedings.mlr.press/v80/serra18a).</span>
</span><span id="HATMaskBackbone.get_mask-238"><a href="#HATMaskBackbone.get_mask-238"><span class="linenos">238</span></a>                <span class="n">mask</span><span class="p">[</span><span class="n">layer_name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gate_fn</span><span class="p">(</span>
</span><span id="HATMaskBackbone.get_mask-239"><a href="#HATMaskBackbone.get_mask-239"><span class="linenos">239</span></a>                    <span class="bp">self</span><span class="o">.</span><span class="n">task_embedding_t</span><span class="p">[</span><span class="n">layer_name</span><span class="p">]</span><span class="o">.</span><span class="n">weight</span> <span class="o">*</span> <span class="n">anneal_scalar</span>
</span><span id="HATMaskBackbone.get_mask-240"><a href="#HATMaskBackbone.get_mask-240"><span class="linenos">240</span></a>                <span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
</span><span id="HATMaskBackbone.get_mask-241"><a href="#HATMaskBackbone.get_mask-241"><span class="linenos">241</span></a>        <span class="k">elif</span> <span class="n">stage</span> <span class="o">==</span> <span class="s2">&quot;validation&quot;</span><span class="p">:</span>
</span><span id="HATMaskBackbone.get_mask-242"><a href="#HATMaskBackbone.get_mask-242"><span class="linenos">242</span></a>            <span class="k">for</span> <span class="n">layer_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted_layer_names</span><span class="p">:</span>
</span><span id="HATMaskBackbone.get_mask-243"><a href="#HATMaskBackbone.get_mask-243"><span class="linenos">243</span></a>                <span class="n">mask</span><span class="p">[</span><span class="n">layer_name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gate_fn</span><span class="p">(</span>
</span><span id="HATMaskBackbone.get_mask-244"><a href="#HATMaskBackbone.get_mask-244"><span class="linenos">244</span></a>                    <span class="bp">self</span><span class="o">.</span><span class="n">task_embedding_t</span><span class="p">[</span><span class="n">layer_name</span><span class="p">]</span><span class="o">.</span><span class="n">weight</span> <span class="o">*</span> <span class="n">s_max</span>
</span><span id="HATMaskBackbone.get_mask-245"><a href="#HATMaskBackbone.get_mask-245"><span class="linenos">245</span></a>                <span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
</span><span id="HATMaskBackbone.get_mask-246"><a href="#HATMaskBackbone.get_mask-246"><span class="linenos">246</span></a>        <span class="k">elif</span> <span class="n">stage</span> <span class="o">==</span> <span class="s2">&quot;test&quot;</span><span class="p">:</span>
</span><span id="HATMaskBackbone.get_mask-247"><a href="#HATMaskBackbone.get_mask-247"><span class="linenos">247</span></a>            <span class="n">mask</span> <span class="o">=</span> <span class="n">test_mask</span>
</span><span id="HATMaskBackbone.get_mask-248"><a href="#HATMaskBackbone.get_mask-248"><span class="linenos">248</span></a>
</span><span id="HATMaskBackbone.get_mask-249"><a href="#HATMaskBackbone.get_mask-249"><span class="linenos">249</span></a>        <span class="k">return</span> <span class="n">mask</span>
</span></pre></div>


            <div class="docstring"><p>Get the hard attention mask used in <code><a href="#HATMaskBackbone.forward">forward()</a></code> method for different stages.</p>

<p><strong>Args:</strong></p>

<ul>
<li><strong>stage</strong> (<code>str</code>): the stage when applying the conversion, should be one of the following:
<ol>
<li>'train': training stage. If stage is 'train', get the mask from task embedding of current task through the gate function, which is scaled by an annealed scalar. See chapter 2.4 "Hard Attention Training" in <a href="http://proceedings.mlr.press/v80/serra18a">HAT paper</a>.</li>
<li>‘validation': validation stage. If stage is 'validation', get the mask from task embedding of current task through the gate function, which is scaled by <code>s_max</code>. (Note that in this stage, the binary mask hasn't been stored yet as the training is not over.)</li>
<li>'test': testing stage. If stage is 'test', apply the mask gate function is scaled by <code>s_max</code>, the large scaling making masks nearly binary.</li>
</ol></li>
<li><strong>s_max</strong> (<code><a href="#HATMaskBackbone.float">float</a></code>): the maximum scaling factor in the gate function. Doesn't apply to testing stage. See chapter 2.4 "Hard Attention Training" in <a href="http://proceedings.mlr.press/v80/serra18a">HAT paper</a>.</li>
<li><strong>batch_idx</strong> (<code>int</code> | <code>None</code>): the current batch index. Applies only to training stage. For other stages, it is default <code>None</code>.</li>
<li><strong>num_batches</strong> (<code>int</code> | <code>None</code>): the total number of batches. Applies only to training stage. For other stages, it is default <code>None</code>.</li>
<li><strong>test_mask</strong> (<code>dict[str, Tensor]</code> | <code>None</code>): the binary mask used for test. Applies only to testing stage. For other stages, it is default <code>None</code>.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li><strong>mask</strong> (<code>dict[str, Tensor]</code>): the hard attention (whose values are 0 or 1) mask. Key (<code>str</code>) is layer name, value (<code>Tensor</code>) is the mask tensor. The mask tensor has size (number of units).</li>
</ul>

<p><strong>Raises:</strong></p>

<ul>
<li><strong>ValueError</strong>: if the <code>batch_idx</code> and <code>batch_num</code> are not provided in 'train' stage; if the <code>s_max</code> is not provided in 'validation' stage; if the <code><a href="#HATMaskBackbone.task_id">task_id</a></code> is not provided in 'test' stage.</li>
</ul>
</div>


                            </div>
                            <div id="HATMaskBackbone.get_cumulative_mask" class="classattr">
                                        <input id="HATMaskBackbone.get_cumulative_mask-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">get_cumulative_mask</span><span class="signature pdoc-code condensed">(<span class="param"><span class="bp">self</span></span><span class="return-annotation">) -> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span>:</span></span>

                <label class="view-source-button" for="HATMaskBackbone.get_cumulative_mask-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#HATMaskBackbone.get_cumulative_mask"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="HATMaskBackbone.get_cumulative_mask-251"><a href="#HATMaskBackbone.get_cumulative_mask-251"><span class="linenos">251</span></a>    <span class="k">def</span><span class="w"> </span><span class="nf">get_cumulative_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]:</span>
</span><span id="HATMaskBackbone.get_cumulative_mask-252"><a href="#HATMaskBackbone.get_cumulative_mask-252"><span class="linenos">252</span></a><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Get the cumulative mask till current task.</span>
</span><span id="HATMaskBackbone.get_cumulative_mask-253"><a href="#HATMaskBackbone.get_cumulative_mask-253"><span class="linenos">253</span></a>
</span><span id="HATMaskBackbone.get_cumulative_mask-254"><a href="#HATMaskBackbone.get_cumulative_mask-254"><span class="linenos">254</span></a><span class="sd">        **Returns:**</span>
</span><span id="HATMaskBackbone.get_cumulative_mask-255"><a href="#HATMaskBackbone.get_cumulative_mask-255"><span class="linenos">255</span></a><span class="sd">        - **cumulative_mask** (`dict[str, Tensor]`): the cumulative mask. Key (`str`) is layer name, value (`Tensor`) is the mask tensor. The mask tensor has size (number of units).</span>
</span><span id="HATMaskBackbone.get_cumulative_mask-256"><a href="#HATMaskBackbone.get_cumulative_mask-256"><span class="linenos">256</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="HATMaskBackbone.get_cumulative_mask-257"><a href="#HATMaskBackbone.get_cumulative_mask-257"><span class="linenos">257</span></a>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cumulative_mask_for_previous_tasks</span>
</span></pre></div>


            <div class="docstring"><p>Get the cumulative mask till current task.</p>

<p><strong>Returns:</strong></p>

<ul>
<li><strong>cumulative_mask</strong> (<code>dict[str, Tensor]</code>): the cumulative mask. Key (<code>str</code>) is layer name, value (<code>Tensor</code>) is the mask tensor. The mask tensor has size (number of units).</li>
</ul>
</div>


                            </div>
                            <div id="HATMaskBackbone.get_summative_mask" class="classattr">
                                        <input id="HATMaskBackbone.get_summative_mask-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">get_summative_mask</span><span class="signature pdoc-code condensed">(<span class="param"><span class="bp">self</span></span><span class="return-annotation">) -> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span>:</span></span>

                <label class="view-source-button" for="HATMaskBackbone.get_summative_mask-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#HATMaskBackbone.get_summative_mask"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="HATMaskBackbone.get_summative_mask-259"><a href="#HATMaskBackbone.get_summative_mask-259"><span class="linenos">259</span></a>    <span class="k">def</span><span class="w"> </span><span class="nf">get_summative_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]:</span>
</span><span id="HATMaskBackbone.get_summative_mask-260"><a href="#HATMaskBackbone.get_summative_mask-260"><span class="linenos">260</span></a><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Get the summative mask till current task.</span>
</span><span id="HATMaskBackbone.get_summative_mask-261"><a href="#HATMaskBackbone.get_summative_mask-261"><span class="linenos">261</span></a>
</span><span id="HATMaskBackbone.get_summative_mask-262"><a href="#HATMaskBackbone.get_summative_mask-262"><span class="linenos">262</span></a><span class="sd">        **Returns:**</span>
</span><span id="HATMaskBackbone.get_summative_mask-263"><a href="#HATMaskBackbone.get_summative_mask-263"><span class="linenos">263</span></a><span class="sd">        - **summative_mask** (`dict[str, Tensor]`): the summative mask tensor. Key (`str`) is layer name, value (`Tensor`) is the mask tensor. The mask tensor has size (number of units).</span>
</span><span id="HATMaskBackbone.get_summative_mask-264"><a href="#HATMaskBackbone.get_summative_mask-264"><span class="linenos">264</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="HATMaskBackbone.get_summative_mask-265"><a href="#HATMaskBackbone.get_summative_mask-265"><span class="linenos">265</span></a>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">summative_mask_for_previous_tasks</span>
</span></pre></div>


            <div class="docstring"><p>Get the summative mask till current task.</p>

<p><strong>Returns:</strong></p>

<ul>
<li><strong>summative_mask</strong> (<code>dict[str, Tensor]</code>): the summative mask tensor. Key (<code>str</code>) is layer name, value (<code>Tensor</code>) is the mask tensor. The mask tensor has size (number of units).</li>
</ul>
</div>


                            </div>
                            <div id="HATMaskBackbone.get_layer_measure_parameter_wise" class="classattr">
                                        <input id="HATMaskBackbone.get_layer_measure_parameter_wise-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">get_layer_measure_parameter_wise</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="bp">self</span>,</span><span class="param">	<span class="n">unit_wise_measure</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span>,</span><span class="param">	<span class="n">layer_name</span><span class="p">:</span> <span class="nb">str</span>,</span><span class="param">	<span class="n">aggregation</span><span class="p">:</span> <span class="nb">str</span></span><span class="return-annotation">) -> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span>:</span></span>

                <label class="view-source-button" for="HATMaskBackbone.get_layer_measure_parameter_wise-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#HATMaskBackbone.get_layer_measure_parameter_wise"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-267"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-267"><span class="linenos">267</span></a>    <span class="k">def</span><span class="w"> </span><span class="nf">get_layer_measure_parameter_wise</span><span class="p">(</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-268"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-268"><span class="linenos">268</span></a>        <span class="bp">self</span><span class="p">,</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-269"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-269"><span class="linenos">269</span></a>        <span class="n">unit_wise_measure</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">],</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-270"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-270"><span class="linenos">270</span></a>        <span class="n">layer_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-271"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-271"><span class="linenos">271</span></a>        <span class="n">aggregation</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-272"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-272"><span class="linenos">272</span></a>    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-273"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-273"><span class="linenos">273</span></a><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Get the parameter-wise measure on the parameters right before the given layer.</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-274"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-274"><span class="linenos">274</span></a>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-275"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-275"><span class="linenos">275</span></a><span class="sd">        It is calculated from the given unit-wise measure. It aggregates two feature-sized vectors (corresponding the given layer and preceding layer) into a weight-wise matrix (corresponding the weights in between) and bias-wise vector (corresponding the bias of the given layer), using the given aggregation method. For example, given two feature-sized measure $m_{l,i}$ and $m_{l-1,j}$ and &#39;min&#39; aggregation, the parameter-wise measure is then $\min \left(a_{l,i}, a_{l-1,j}\right)$, a matrix with respect to $i, j$.</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-276"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-276"><span class="linenos">276</span></a>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-277"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-277"><span class="linenos">277</span></a><span class="sd">        Note that if the given layer is the first layer with no preceding layer, we will get parameter-wise measure directly broadcasted from the unit-wise measure of given layer.</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-278"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-278"><span class="linenos">278</span></a>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-279"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-279"><span class="linenos">279</span></a><span class="sd">        This method is used in the calculation of parameter-wise measure in various HAT-based algorithms:</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-280"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-280"><span class="linenos">280</span></a>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-281"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-281"><span class="linenos">281</span></a><span class="sd">        - **HAT**: the parameter-wise measure is the binary mask for previous tasks from the unit-wise cumulative mask of previous tasks `self.cumulative_mask_for_previous_tasks`, which is $\min \left(a_{l,i}^{&lt;t}, a_{l-1,j}^{&lt;t}\right)$ in equation (2) in [HAT paper](http://proceedings.mlr.press/v80/serra18a).</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-282"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-282"><span class="linenos">282</span></a><span class="sd">        - **AdaHAT**: the parameter-wise measure is the parameter importance for previous tasks from the unit-wise summative mask of previous tasks `self.summative_mask_for_previous_tasks`, which is $\min \left(m_{l,i}^{&lt;t,\text{sum}}, m_{l-1,j}^{&lt;t,\text{sum}}\right)$ in equation (9) in [AdaHAT paper](https://link.springer.com/chapter/10.1007/978-3-031-70352-2_9).</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-283"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-283"><span class="linenos">283</span></a><span class="sd">        - **CBPHAT**: the parameter-wise measure is the parameter importance for previous tasks from the unit-wise importance of previous tasks `self.unit_importance_for_previous_tasks` based on contribution utility, which is $\min \left(I_{l,i}^{(t-1)}, I_{l-1,j}^{(t-1)}\right)$ in the adjustment rate formula in the paper draft.</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-284"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-284"><span class="linenos">284</span></a>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-285"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-285"><span class="linenos">285</span></a><span class="sd">        **Args:**</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-286"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-286"><span class="linenos">286</span></a><span class="sd">        - **unit_wise_measure** (`dict[str, Tensor]`): the unit-wise measure. Key is layer name, value is the unit-wise measure tensor. The measure tensor has size (number of units).</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-287"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-287"><span class="linenos">287</span></a><span class="sd">        - **layer_name** (`str`): the name of given layer.</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-288"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-288"><span class="linenos">288</span></a><span class="sd">        - **aggregation** (`str`): the aggregation method turning two feature-wise measures into weight-wise matrix, should be one of the following:</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-289"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-289"><span class="linenos">289</span></a><span class="sd">            - &#39;min&#39;: takes minimum of the two connected unit measures.</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-290"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-290"><span class="linenos">290</span></a><span class="sd">            - &#39;max&#39;: takes maximum of the two connected unit measures.</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-291"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-291"><span class="linenos">291</span></a>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-292"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-292"><span class="linenos">292</span></a><span class="sd">        **Returns:**</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-293"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-293"><span class="linenos">293</span></a><span class="sd">        - **weight_measure** (`Tensor`): the weight measure matrix, same size as the corresponding weights.</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-294"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-294"><span class="linenos">294</span></a><span class="sd">        - **bias_measure** (`Tensor`): the bias measure vector, same size as the corresponding bias.</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-295"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-295"><span class="linenos">295</span></a>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-296"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-296"><span class="linenos">296</span></a>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-297"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-297"><span class="linenos">297</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-298"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-298"><span class="linenos">298</span></a>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-299"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-299"><span class="linenos">299</span></a>        <span class="c1"># initialise the aggregation function</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-300"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-300"><span class="linenos">300</span></a>        <span class="k">if</span> <span class="n">aggregation</span> <span class="o">==</span> <span class="s2">&quot;min&quot;</span><span class="p">:</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-301"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-301"><span class="linenos">301</span></a>            <span class="n">aggregation_func</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">min</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-302"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-302"><span class="linenos">302</span></a>        <span class="k">elif</span> <span class="n">aggregation</span> <span class="o">==</span> <span class="s2">&quot;max&quot;</span><span class="p">:</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-303"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-303"><span class="linenos">303</span></a>            <span class="n">aggregation_func</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-304"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-304"><span class="linenos">304</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-305"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-305"><span class="linenos">305</span></a>            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The aggregation method </span><span class="si">{</span><span class="n">aggregation</span><span class="si">}</span><span class="s2"> is not supported.&quot;</span><span class="p">)</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-306"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-306"><span class="linenos">306</span></a>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-307"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-307"><span class="linenos">307</span></a>        <span class="c1"># get the preceding layer name</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-308"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-308"><span class="linenos">308</span></a>        <span class="n">preceding_layer_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preceding_layer_name</span><span class="p">(</span><span class="n">layer_name</span><span class="p">)</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-309"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-309"><span class="linenos">309</span></a>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-310"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-310"><span class="linenos">310</span></a>        <span class="c1"># get weight size for expanding the measures</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-311"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-311"><span class="linenos">311</span></a>        <span class="n">layer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_layer_by_name</span><span class="p">(</span><span class="n">layer_name</span><span class="p">)</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-312"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-312"><span class="linenos">312</span></a>        <span class="n">weight_size</span> <span class="o">=</span> <span class="n">layer</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-313"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-313"><span class="linenos">313</span></a>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-314"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-314"><span class="linenos">314</span></a>        <span class="c1"># construct the weight-wise measure</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-315"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-315"><span class="linenos">315</span></a>        <span class="n">layer_measure</span> <span class="o">=</span> <span class="n">unit_wise_measure</span><span class="p">[</span><span class="n">layer_name</span><span class="p">]</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-316"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-316"><span class="linenos">316</span></a>        <span class="n">layer_measure_broadcast_size</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-317"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-317"><span class="linenos">317</span></a>            <span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">weight_size</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-318"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-318"><span class="linenos">318</span></a>        <span class="p">)</span>  <span class="c1"># since the size of mask tensor is (number of units), we extend it to (number of units, 1) and expand it to the weight size. The weight size has 2 dimensions in fully connected layers and 4 dimensions in convolutional layers</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-319"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-319"><span class="linenos">319</span></a>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-320"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-320"><span class="linenos">320</span></a>        <span class="n">layer_measure_broadcasted</span> <span class="o">=</span> <span class="n">layer_measure</span><span class="o">.</span><span class="n">view</span><span class="p">(</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-321"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-321"><span class="linenos">321</span></a>            <span class="o">*</span><span class="n">layer_measure_broadcast_size</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-322"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-322"><span class="linenos">322</span></a>        <span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-323"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-323"><span class="linenos">323</span></a>            <span class="n">weight_size</span><span class="p">,</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-324"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-324"><span class="linenos">324</span></a>        <span class="p">)</span>  <span class="c1"># expand the given layer mask to the weight size and broadcast</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-325"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-325"><span class="linenos">325</span></a>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-326"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-326"><span class="linenos">326</span></a>        <span class="k">if</span> <span class="p">(</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-327"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-327"><span class="linenos">327</span></a>            <span class="n">preceding_layer_name</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-328"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-328"><span class="linenos">328</span></a>        <span class="p">):</span>  <span class="c1"># if the layer is not the first layer, where the preceding layer exists</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-329"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-329"><span class="linenos">329</span></a>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-330"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-330"><span class="linenos">330</span></a>            <span class="n">preceding_layer_measure_broadcast_size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-331"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-331"><span class="linenos">331</span></a>                <span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">weight_size</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-332"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-332"><span class="linenos">332</span></a>            <span class="p">)</span>  <span class="c1"># since the size of mask tensor is (number of units), we extend it to (1, number of units) and expand it to the weight size. The weight size has 2 dimensions in fully connected layers and 4 dimensions in convolutional layers</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-333"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-333"><span class="linenos">333</span></a>            <span class="n">preceding_layer_measure</span> <span class="o">=</span> <span class="n">unit_wise_measure</span><span class="p">[</span><span class="n">preceding_layer_name</span><span class="p">]</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-334"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-334"><span class="linenos">334</span></a>            <span class="n">preceding_layer_measure_broadcasted</span> <span class="o">=</span> <span class="n">preceding_layer_measure</span><span class="o">.</span><span class="n">view</span><span class="p">(</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-335"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-335"><span class="linenos">335</span></a>                <span class="o">*</span><span class="n">preceding_layer_measure_broadcast_size</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-336"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-336"><span class="linenos">336</span></a>            <span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-337"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-337"><span class="linenos">337</span></a>                <span class="n">weight_size</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-338"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-338"><span class="linenos">338</span></a>            <span class="p">)</span>  <span class="c1"># expand the preceding layer mask to the weight size and broadcast</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-339"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-339"><span class="linenos">339</span></a>            <span class="n">weight_measure</span> <span class="o">=</span> <span class="n">aggregation_func</span><span class="p">(</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-340"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-340"><span class="linenos">340</span></a>                <span class="n">layer_measure_broadcasted</span><span class="p">,</span> <span class="n">preceding_layer_measure_broadcasted</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-341"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-341"><span class="linenos">341</span></a>            <span class="p">)</span>  <span class="c1"># get the minimum of the two mask vectors, from expanded</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-342"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-342"><span class="linenos">342</span></a>        <span class="k">else</span><span class="p">:</span>  <span class="c1"># if the layer is the first layer</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-343"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-343"><span class="linenos">343</span></a>            <span class="n">weight_measure</span> <span class="o">=</span> <span class="n">layer_measure_broadcasted</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-344"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-344"><span class="linenos">344</span></a>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-345"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-345"><span class="linenos">345</span></a>        <span class="c1"># construct the bias-wise measure</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-346"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-346"><span class="linenos">346</span></a>        <span class="n">bias_measure</span> <span class="o">=</span> <span class="n">layer_measure</span>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-347"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-347"><span class="linenos">347</span></a>
</span><span id="HATMaskBackbone.get_layer_measure_parameter_wise-348"><a href="#HATMaskBackbone.get_layer_measure_parameter_wise-348"><span class="linenos">348</span></a>        <span class="k">return</span> <span class="n">weight_measure</span><span class="p">,</span> <span class="n">bias_measure</span>
</span></pre></div>


            <div class="docstring"><p>Get the parameter-wise measure on the parameters right before the given layer.</p>

<p>It is calculated from the given unit-wise measure. It aggregates two feature-sized vectors (corresponding the given layer and preceding layer) into a weight-wise matrix (corresponding the weights in between) and bias-wise vector (corresponding the bias of the given layer), using the given aggregation method. For example, given two feature-sized measure $m_{l,i}$ and $m_{l-1,j}$ and 'min' aggregation, the parameter-wise measure is then $\min \left(a_{l,i}, a_{l-1,j}\right)$, a matrix with respect to $i, j$.</p>

<p>Note that if the given layer is the first layer with no preceding layer, we will get parameter-wise measure directly broadcasted from the unit-wise measure of given layer.</p>

<p>This method is used in the calculation of parameter-wise measure in various HAT-based algorithms:</p>

<ul>
<li><strong>HAT</strong>: the parameter-wise measure is the binary mask for previous tasks from the unit-wise cumulative mask of previous tasks <code>self.cumulative_mask_for_previous_tasks</code>, which is $\min \left(a_{l,i}^{<t}, a_{l-1,j}^{<t}\right)$ in equation (2) in <a href="http://proceedings.mlr.press/v80/serra18a">HAT paper</a>.</li>
<li><strong>AdaHAT</strong>: the parameter-wise measure is the parameter importance for previous tasks from the unit-wise summative mask of previous tasks <code>self.summative_mask_for_previous_tasks</code>, which is $\min \left(m_{l,i}^{<t,\text{sum}}, m_{l-1,j}^{<t,\text{sum}}\right)$ in equation (9) in <a href="https://link.springer.com/chapter/10.1007/978-3-031-70352-2_9">AdaHAT paper</a>.</li>
<li><strong>CBPHAT</strong>: the parameter-wise measure is the parameter importance for previous tasks from the unit-wise importance of previous tasks <code>self.unit_importance_for_previous_tasks</code> based on contribution utility, which is $\min \left(I_{l,i}^{(t-1)}, I_{l-1,j}^{(t-1)}\right)$ in the adjustment rate formula in the paper draft.</li>
</ul>

<p><strong>Args:</strong></p>

<ul>
<li><strong>unit_wise_measure</strong> (<code>dict[str, Tensor]</code>): the unit-wise measure. Key is layer name, value is the unit-wise measure tensor. The measure tensor has size (number of units).</li>
<li><strong>layer_name</strong> (<code>str</code>): the name of given layer.</li>
<li><strong>aggregation</strong> (<code>str</code>): the aggregation method turning two feature-wise measures into weight-wise matrix, should be one of the following:
<ul>
<li>'min': takes minimum of the two connected unit measures.</li>
<li>'max': takes maximum of the two connected unit measures.</li>
</ul></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li><strong>weight_measure</strong> (<code>Tensor</code>): the weight measure matrix, same size as the corresponding weights.</li>
<li><strong>bias_measure</strong> (<code>Tensor</code>): the bias measure vector, same size as the corresponding bias.</li>
</ul>
</div>


                            </div>
                            <div id="HATMaskBackbone.forward" class="classattr">
                                        <input id="HATMaskBackbone.forward-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
                    <div class="decorator decorator-override">@override</div>

        <span class="def">def</span>
        <span class="name">forward</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="bp">self</span>,</span><span class="param">	<span class="nb">input</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span>,</span><span class="param">	<span class="n">stage</span><span class="p">:</span> <span class="nb">str</span>,</span><span class="param">	<span class="n">s_max</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>,</span><span class="param">	<span class="n">batch_idx</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>,</span><span class="param">	<span class="n">num_batches</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>,</span><span class="param">	<span class="n">test_mask</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span></span><span class="return-annotation">) -> <span class="nb">tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]</span>:</span></span>

                <label class="view-source-button" for="HATMaskBackbone.forward-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#HATMaskBackbone.forward"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="HATMaskBackbone.forward-350"><a href="#HATMaskBackbone.forward-350"><span class="linenos">350</span></a>    <span class="nd">@override</span>
</span><span id="HATMaskBackbone.forward-351"><a href="#HATMaskBackbone.forward-351"><span class="linenos">351</span></a>    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span>
</span><span id="HATMaskBackbone.forward-352"><a href="#HATMaskBackbone.forward-352"><span class="linenos">352</span></a>        <span class="bp">self</span><span class="p">,</span>
</span><span id="HATMaskBackbone.forward-353"><a href="#HATMaskBackbone.forward-353"><span class="linenos">353</span></a>        <span class="nb">input</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
</span><span id="HATMaskBackbone.forward-354"><a href="#HATMaskBackbone.forward-354"><span class="linenos">354</span></a>        <span class="n">stage</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
</span><span id="HATMaskBackbone.forward-355"><a href="#HATMaskBackbone.forward-355"><span class="linenos">355</span></a>        <span class="n">s_max</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
</span><span id="HATMaskBackbone.forward-356"><a href="#HATMaskBackbone.forward-356"><span class="linenos">356</span></a>        <span class="n">batch_idx</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
</span><span id="HATMaskBackbone.forward-357"><a href="#HATMaskBackbone.forward-357"><span class="linenos">357</span></a>        <span class="n">num_batches</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
</span><span id="HATMaskBackbone.forward-358"><a href="#HATMaskBackbone.forward-358"><span class="linenos">358</span></a>        <span class="n">test_mask</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
</span><span id="HATMaskBackbone.forward-359"><a href="#HATMaskBackbone.forward-359"><span class="linenos">359</span></a>    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]]:</span>
</span><span id="HATMaskBackbone.forward-360"><a href="#HATMaskBackbone.forward-360"><span class="linenos">360</span></a><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;The forward pass for data from task `task_id`. Task-specific mask for `task_id` are applied to the units in each layer.</span>
</span><span id="HATMaskBackbone.forward-361"><a href="#HATMaskBackbone.forward-361"><span class="linenos">361</span></a>
</span><span id="HATMaskBackbone.forward-362"><a href="#HATMaskBackbone.forward-362"><span class="linenos">362</span></a><span class="sd">        **Args:**</span>
</span><span id="HATMaskBackbone.forward-363"><a href="#HATMaskBackbone.forward-363"><span class="linenos">363</span></a><span class="sd">        - **input** (`Tensor`): The input tensor from data.</span>
</span><span id="HATMaskBackbone.forward-364"><a href="#HATMaskBackbone.forward-364"><span class="linenos">364</span></a><span class="sd">        - **stage** (`str`): the stage of the forward pass, should be one of the following:</span>
</span><span id="HATMaskBackbone.forward-365"><a href="#HATMaskBackbone.forward-365"><span class="linenos">365</span></a><span class="sd">            1. &#39;train&#39;: training stage.</span>
</span><span id="HATMaskBackbone.forward-366"><a href="#HATMaskBackbone.forward-366"><span class="linenos">366</span></a><span class="sd">            2. &#39;validation&#39;: validation stage.</span>
</span><span id="HATMaskBackbone.forward-367"><a href="#HATMaskBackbone.forward-367"><span class="linenos">367</span></a><span class="sd">            3. &#39;test&#39;: testing stage.</span>
</span><span id="HATMaskBackbone.forward-368"><a href="#HATMaskBackbone.forward-368"><span class="linenos">368</span></a><span class="sd">        - **s_max** (`float`): the maximum scaling factor in the gate function. See chapter 2.4 &quot;Hard Attention Training&quot; in [HAT paper](http://proceedings.mlr.press/v80/serra18a).</span>
</span><span id="HATMaskBackbone.forward-369"><a href="#HATMaskBackbone.forward-369"><span class="linenos">369</span></a><span class="sd">        - **batch_idx** (`int` | `None`): the current batch index. Applies only to training stage. For other stages, it is default `None`.</span>
</span><span id="HATMaskBackbone.forward-370"><a href="#HATMaskBackbone.forward-370"><span class="linenos">370</span></a><span class="sd">        - **num_batches** (`int` | `None`): the total number of batches. Applies only to training stage. For other stages, it is default `None`.</span>
</span><span id="HATMaskBackbone.forward-371"><a href="#HATMaskBackbone.forward-371"><span class="linenos">371</span></a><span class="sd">        - **test_mask** (`dict[str, Tensor]` | `None`): the binary mask used for test. Applies only to testing stage. For other stages, it is default `None`.</span>
</span><span id="HATMaskBackbone.forward-372"><a href="#HATMaskBackbone.forward-372"><span class="linenos">372</span></a>
</span><span id="HATMaskBackbone.forward-373"><a href="#HATMaskBackbone.forward-373"><span class="linenos">373</span></a><span class="sd">        **Returns:**</span>
</span><span id="HATMaskBackbone.forward-374"><a href="#HATMaskBackbone.forward-374"><span class="linenos">374</span></a><span class="sd">        - **output_feature** (`Tensor`): the output feature tensor to be passed into heads. This is the main target of backpropagation.</span>
</span><span id="HATMaskBackbone.forward-375"><a href="#HATMaskBackbone.forward-375"><span class="linenos">375</span></a><span class="sd">        - **mask** (`dict[str, Tensor]`): the mask for the current task. Key (`str`) is layer name, value (`Tensor`) is the mask tensor. The mask tensor has size (number of units).</span>
</span><span id="HATMaskBackbone.forward-376"><a href="#HATMaskBackbone.forward-376"><span class="linenos">376</span></a><span class="sd">        - **activations** (`dict[str, Tensor]`): the hidden features (after activation) in each weighted layer. Key (`str`) is the weighted layer name, value (`Tensor`) is the hidden feature tensor. This is used for the continual learning algorithms that need to use the hidden features for various purposes. Although HAT algorithm does not need this, it is still provided for API consistence for other HAT-based algorithms inherited this `forward()` method of `HAT` class.</span>
</span><span id="HATMaskBackbone.forward-377"><a href="#HATMaskBackbone.forward-377"><span class="linenos">377</span></a>
</span><span id="HATMaskBackbone.forward-378"><a href="#HATMaskBackbone.forward-378"><span class="linenos">378</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="HATMaskBackbone.forward-379"><a href="#HATMaskBackbone.forward-379"><span class="linenos">379</span></a>        <span class="c1"># this should be copied to all subclasses. Make sure it is called to get the mask for the current task from the task embedding in this stage</span>
</span><span id="HATMaskBackbone.forward-380"><a href="#HATMaskBackbone.forward-380"><span class="linenos">380</span></a>        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_mask</span><span class="p">(</span>
</span><span id="HATMaskBackbone.forward-381"><a href="#HATMaskBackbone.forward-381"><span class="linenos">381</span></a>            <span class="n">stage</span><span class="p">,</span>
</span><span id="HATMaskBackbone.forward-382"><a href="#HATMaskBackbone.forward-382"><span class="linenos">382</span></a>            <span class="n">s_max</span><span class="o">=</span><span class="n">s_max</span><span class="p">,</span>
</span><span id="HATMaskBackbone.forward-383"><a href="#HATMaskBackbone.forward-383"><span class="linenos">383</span></a>            <span class="n">batch_idx</span><span class="o">=</span><span class="n">batch_idx</span><span class="p">,</span>
</span><span id="HATMaskBackbone.forward-384"><a href="#HATMaskBackbone.forward-384"><span class="linenos">384</span></a>            <span class="n">num_batches</span><span class="o">=</span><span class="n">num_batches</span><span class="p">,</span>
</span><span id="HATMaskBackbone.forward-385"><a href="#HATMaskBackbone.forward-385"><span class="linenos">385</span></a>            <span class="n">test_mask</span><span class="o">=</span><span class="n">test_mask</span><span class="p">,</span>
</span><span id="HATMaskBackbone.forward-386"><a href="#HATMaskBackbone.forward-386"><span class="linenos">386</span></a>        <span class="p">)</span>
</span></pre></div>


            <div class="docstring"><p>The forward pass for data from task <code><a href="#HATMaskBackbone.task_id">task_id</a></code>. Task-specific mask for <code><a href="#HATMaskBackbone.task_id">task_id</a></code> are applied to the units in each layer.</p>

<p><strong>Args:</strong></p>

<ul>
<li><strong>input</strong> (<code>Tensor</code>): The input tensor from data.</li>
<li><strong>stage</strong> (<code>str</code>): the stage of the forward pass, should be one of the following:
<ol>
<li>'train': training stage.</li>
<li>'validation': validation stage.</li>
<li>'test': testing stage.</li>
</ol></li>
<li><strong>s_max</strong> (<code><a href="#HATMaskBackbone.float">float</a></code>): the maximum scaling factor in the gate function. See chapter 2.4 "Hard Attention Training" in <a href="http://proceedings.mlr.press/v80/serra18a">HAT paper</a>.</li>
<li><strong>batch_idx</strong> (<code>int</code> | <code>None</code>): the current batch index. Applies only to training stage. For other stages, it is default <code>None</code>.</li>
<li><strong>num_batches</strong> (<code>int</code> | <code>None</code>): the total number of batches. Applies only to training stage. For other stages, it is default <code>None</code>.</li>
<li><strong>test_mask</strong> (<code>dict[str, Tensor]</code> | <code>None</code>): the binary mask used for test. Applies only to testing stage. For other stages, it is default <code>None</code>.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li><strong>output_feature</strong> (<code>Tensor</code>): the output feature tensor to be passed into heads. This is the main target of backpropagation.</li>
<li><strong>mask</strong> (<code>dict[str, Tensor]</code>): the mask for the current task. Key (<code>str</code>) is layer name, value (<code>Tensor</code>) is the mask tensor. The mask tensor has size (number of units).</li>
<li><strong>activations</strong> (<code>dict[str, Tensor]</code>): the hidden features (after activation) in each weighted layer. Key (<code>str</code>) is the weighted layer name, value (<code>Tensor</code>) is the hidden feature tensor. This is used for the continual learning algorithms that need to use the hidden features for various purposes. Although HAT algorithm does not need this, it is still provided for API consistence for other HAT-based algorithms inherited this <code><a href="#HATMaskBackbone.forward">forward()</a></code> method of <code>HAT</code> class.</li>
</ul>
</div>


                            </div>
                </section>
    </main>
<script>
    function escapeHTML(html) {
        return document.createElement('div').appendChild(document.createTextNode(html)).parentNode.innerHTML;
    }

    const originalContent = document.querySelector("main.pdoc");
    let currentContent = originalContent;

    function setContent(innerHTML) {
        let elem;
        if (innerHTML) {
            elem = document.createElement("main");
            elem.classList.add("pdoc");
            elem.innerHTML = innerHTML;
        } else {
            elem = originalContent;
        }
        if (currentContent !== elem) {
            currentContent.replaceWith(elem);
            currentContent = elem;
        }
    }

    function getSearchTerm() {
        return (new URL(window.location)).searchParams.get("search");
    }

    const searchBox = document.querySelector(".pdoc input[type=search]");
    searchBox.addEventListener("input", function () {
        let url = new URL(window.location);
        if (searchBox.value.trim()) {
            url.hash = "";
            url.searchParams.set("search", searchBox.value);
        } else {
            url.searchParams.delete("search");
        }
        history.replaceState("", "", url.toString());
        onInput();
    });
    window.addEventListener("popstate", onInput);


    let search, searchErr;

    async function initialize() {
        try {
            search = await new Promise((resolve, reject) => {
                const script = document.createElement("script");
                script.type = "text/javascript";
                script.async = true;
                script.onload = () => resolve(window.pdocSearch);
                script.onerror = (e) => reject(e);
                script.src = "../search.js";
                document.getElementsByTagName("head")[0].appendChild(script);
            });
        } catch (e) {
            console.error("Cannot fetch pdoc search index");
            searchErr = "Cannot fetch search index.";
        }
        onInput();

        document.querySelector("nav.pdoc").addEventListener("click", e => {
            if (e.target.hash) {
                searchBox.value = "";
                searchBox.dispatchEvent(new Event("input"));
            }
        });
    }

    function onInput() {
        setContent((() => {
            const term = getSearchTerm();
            if (!term) {
                return null
            }
            if (searchErr) {
                return `<h3>Error: ${searchErr}</h3>`
            }
            if (!search) {
                return "<h3>Searching...</h3>"
            }

            window.scrollTo({top: 0, left: 0, behavior: 'auto'});

            const results = search(term);

            let html;
            if (results.length === 0) {
                html = `No search results for '${escapeHTML(term)}'.`
            } else {
                html = `<h4>${results.length} search result${results.length > 1 ? "s" : ""} for '${escapeHTML(term)}'.</h4>`;
            }
            for (let result of results.slice(0, 10)) {
                let doc = result.doc;
                let url = `../${doc.modulename.replaceAll(".", "/")}.html`;
                if (doc.qualname) {
                    url += `#${doc.qualname}`;
                }

                let heading;
                switch (result.doc.kind) {
                    case "function":
                        if (doc.fullname.endsWith(".__init__")) {
                            heading = `<span class="name">${doc.fullname.replace(/\.__init__$/, "")}</span>${doc.signature}`;
                        } else {
                            heading = `<span class="def">${doc.funcdef}</span> <span class="name">${doc.fullname}</span>${doc.signature}`;
                        }
                        break;
                    case "class":
                        heading = `<span class="def">class</span> <span class="name">${doc.fullname}</span>`;
                        if (doc.bases)
                            heading += `<wbr>(<span class="base">${doc.bases}</span>)`;
                        heading += `:`;
                        break;
                    case "variable":
                        heading = `<span class="name">${doc.fullname}</span>`;
                        if (doc.annotation)
                            heading += `<span class="annotation">${doc.annotation}</span>`;
                        if (doc.default_value)
                            heading += `<span class="default_value"> = ${doc.default_value}</span>`;
                        break;
                    default:
                        heading = `<span class="name">${doc.fullname}</span>`;
                        break;
                }
                html += `
                        <section class="search-result">
                        <a href="${url}" class="attr ${doc.kind}">${heading}</a>
                        <div class="docstring">${doc.doc}</div>
                        </section>
                    `;

            }
            return html;
        })());
    }

    if (getSearchTerm()) {
        initialize();
        searchBox.value = getSearchTerm();
        onInput();
    } else {
        searchBox.addEventListener("focus", initialize, {once: true});
    }

    searchBox.addEventListener("keydown", e => {
        if (["ArrowDown", "ArrowUp", "Enter"].includes(e.key)) {
            let focused = currentContent.querySelector(".search-result.focused");
            if (!focused) {
                currentContent.querySelector(".search-result").classList.add("focused");
            } else if (
                e.key === "ArrowDown"
                && focused.nextElementSibling
                && focused.nextElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.nextElementSibling.classList.add("focused");
                focused.nextElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "ArrowUp"
                && focused.previousElementSibling
                && focused.previousElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.previousElementSibling.classList.add("focused");
                focused.previousElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "Enter"
            ) {
                focused.querySelector("a").click();
            }
        }
    });
</script></body>
</html>